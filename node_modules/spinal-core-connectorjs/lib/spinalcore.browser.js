var _root_obj = this;
(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){
spinalCore = require('../lib/spinalcore.node.js');

},{"../lib/spinalcore.node.js":2}],2:[function(require,module,exports){
/*
* Copyright 2015 SpinalCom - www.spinalcom.com
*
* This file is part of SpinalCore.
*
* Please read all of the following terms and conditions of the Free Software
* license Agreement ("Agreement") carefully.
*
* This Agreement is a legally binding contract between the Licensee (as defined
* below) and SpinalCom that sets forth the terms and conditions that govern
* your use of the Program. By installing and/or using the Program, you agree to
* abide by all the terms and conditions stated or referenced herein.
*
* If you do not agree to abide by these terms and conditions, do not
* demonstrate your acceptance and do not install or use the Program.
*
* You should have received a copy of the license along with this file. If not,
* see <http://resources.spinalcom.com/licenses.pdf>.
*/

// Generated by CoffeeScript 1.12.7
var _index_current_popup, add_class, get_left, get_top, new_alert_msg, new_dom_element, rem_class, root, spinal_new_popup, url,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

url = require('url');

root = typeof _root_obj === "undefined" ? global : window;

root.spinalCore = (function() {
  function spinalCore() {}

  spinalCore._def = {};

  spinalCore.connect = function(options) {
    var auth;
    if (typeof options === 'string') {
      options = url.parse(options);
    }
    if (options.path.slice(-1)[0] !== "/") {
      options.path += "/";
    }
    FileSystem._home_dir = options.path;
    FileSystem._url = options.hostname;
    FileSystem._port = options.port;
    if (options.auth !== null) {
      auth = options.auth.split(":");
      FileSystem._userid = auth[0];
      if (auth.length > 1) {
        FileSystem._password = auth[1];
      }
    } else {
      FileSystem._userid = 644;
      FileSystem._password = "";
    }
    return new FileSystem;
  };

  spinalCore.store = function(fs, model, path, callback_success, callback_error) {
    var file_name, lst;
    if (typeof callback_error === "undefined") {
      callback_error = function() {
        return console.log("Model could not be stored. You can pass a callback to handle this error.");
      };
    }
    lst = path.split("/");
    file_name = lst.pop();
    if (lst[0] === "") {
      lst.splice(0, 1);
    }
    path = lst.join("/");
    return fs.load_or_make_dir(FileSystem._home_dir + path, function(dir, err) {
      var file;
      if (err) {
        return callback_error();
      } else {
        file = dir.detect(function(x) {
          return x.name.get() === file_name;
        });
        if (file != null) {
          dir.remove(file);
        }
        dir.add_file(file_name, model, {
          model_type: "Model"
        });
        return callback_success();
      }
    });
  };

  spinalCore.register_models = function(modelList) {
    var key, len, m, q, results, results1, value;
    if (modelList && modelList instanceof Function) {
      modelList = [modelList];
    }
    if (modelList instanceof Array) {
      results = [];
      for (q = 0, len = modelList.length; q < len; q++) {
        m = modelList[q];
        results.push(spinalCore._def[m.name] = m);
      }
      return results;
    } else {
      results1 = [];
      for (key in modelList) {
        value = modelList[key];
        results1.push(spinalCore._def[key] = value);
      }
      return results1;
    }
  };

  spinalCore.load = function(fs, path, callback_success, callback_error) {
    var file_name, lst;
    if (typeof callback_error === "undefined") {
      callback_error = function() {
        return console.log("Model could not be loaded. You can pass a callback to handle this error.");
      };
    }
    lst = path.split("/");
    file_name = lst.pop();
    if (lst[0] === "") {
      lst.splice(0, 1);
    }
    path = lst.join("/");
    return fs.load_or_make_dir(FileSystem._home_dir + path, function(current_dir, err) {
      var file;
      if (err) {
        return callback_error();
      } else {
        file = current_dir.detect(function(x) {
          return x.name.get() === file_name;
        });
        if (file != null) {
          return file.load(function(data, err) {
            if (err) {
              return callback_error();
            } else {
              return callback_success(data, err);
            }
          });
        } else {
          return callback_error();
        }
      }
    });
  };

  spinalCore.load_type = function(fs, type, callback_success, callback_error) {
    if (typeof callback_error === "undefined") {
      callback_error = function() {
        return console.log("Model of this type could not be loaded. " + "You can pass a callback to handle this error.");
      };
    }
    return fs.load_type(type, function(data, err) {
      if (err) {
        return callback_error();
      } else {
        return callback_success(data, err);
      }
    });
  };

  spinalCore.load_right = function(fs, ptr, callback_success, callback_error) {
    if (typeof callback_error === "undefined") {
      callback_error = function() {
        return console.log("Model Right could not be loaded." + " You can pass a callback to handle this error.");
      };
    }
    return fs.load_right(ptr, function(data, err) {
      if (err) {
        return callback_error();
      } else {
        return callback_success(data, err);
      }
    });
  };

  spinalCore.share_model = function(fs, ptr, file_name, right_flag, targetName) {
    return fs.share_model(ptr, file_name, right_flag, targetName);
  };

  spinalCore.right_flag = {
    AD: 1,
    WR: 2,
    RD: 4
  };

  spinalCore.extend = function(child, parent) {
    var child_name, ctor, key, value;
    for (key in parent) {
      value = parent[key];
      child[key] = value;
    }
    ctor = function() {
      this.constructor = child;
    };
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
    child.__super__ = parent.prototype;
    child.super = function () {
            var args = [];
           	for (var i=1; i < arguments.length; i++)
                args[i-1] = arguments[i];
            child.__super__.constructor.apply(arguments[0], args);
        };
    root = typeof global !== "undefined" && global !== null ? global : window;
    child_name = /^function\s+([\w\$]+)\s*\(/.exec(child.toString())[1];
    return root[child_name] = child;
  };

  return spinalCore;

})();

module.exports = spinalCore;

root = typeof _root_obj === "undefined" ? global : window;

root.ModelProcessManager = (function() {
  function ModelProcessManager() {}

  ModelProcessManager._counter = 0;

  ModelProcessManager._modlist = {};

  ModelProcessManager._n_processes = {};

  ModelProcessManager._cur_mid = 0;

  ModelProcessManager._cur_process_id = 0;

  ModelProcessManager._timeout = void 0;

  ModelProcessManager._force_m = false;

  ModelProcessManager._synchro = void 0;

  ModelProcessManager.new_from_state = function(str) {
    var l, len, lst, map, mid, q, s;
    map = {};
    lst = str.split("\n");
    mid = lst.shift();
    for (q = 0, len = lst.length; q < len; q++) {
      l = lst[q];
      if (!l.length) {
        continue;
      }
      s = l.split(" ");
      map[s[0]] = {
        type: s[1],
        data: s[2],
        buff: void 0
      };
    }
    eval("var __new__ = new " + map[mid].type + ";");
    __new__._set_state(map[mid].data, map);
    return __new__;
  };

  ModelProcessManager.load = function(filename, func) {
    if (!ModelProcessManager.synchronizer) {
      ModelProcessManager._synchro = new Synchronizer;
    }
    return ModelProcessManager._synchro.load(filename, func);
  };

  ModelProcessManager.conv = function(v) {
    if (v instanceof Model) {
      return v;
    }
    if (v instanceof Array) {
      return new Lst(v);
    }
    if (typeof v === "string") {
      return new Str(v);
    }
    if (typeof v === "number") {
      return new Val(v);
    }
    if (typeof v === "boolean") {
      return new Bool(v);
    }
    if (v instanceof Object) {
      return new Model(v);
    }
    return new Obj(v);
  };

  ModelProcessManager.get_object_class = function(obj) {
    var arr;
    if (obj && obj.constructor && obj.constructor.name) {
      return obj.constructor.name;
    }
    if (obj && obj.constructor && obj.constructor.toString) {
      arr = obj.constructor.toString().match(/function\s*(\w+)/);
      if (!arr) {
        arr = obj.constructor.toString().match(/class\s*(\w+)/);
      }
      if (arr && arr.length === 2) {
        return arr[1];
      }
    }
  };

  ModelProcessManager._get_attribute_names = function(m) {
    var key, results, val;
    if (m instanceof Model) {
      return m._attribute_names;
    } else {
      results = [];
      for (key in m) {
        val = m[key];
        results.push(key);
      }
      return results;
    }
  };

  ModelProcessManager._new_model_from_state = function(mid, map) {
    var info;
    info = map[mid];
    eval("info.buff = new " + info.type + ";");
    info.buff._set_state(info.data, map);
    return info.buff;
  };

  ModelProcessManager._need_sync_processes = function() {
    if (ModelProcessManager._timeout == null) {
      return ModelProcessManager._timeout = setTimeout(ModelProcessManager._sync_processes, 1);
    }
  };

  ModelProcessManager._sync_processes = function() {
    var id, len, model, process, processes, q, ref, ref1, ref2;
    processes = {};
    ref = ModelProcessManager._modlist;
    for (id in ref) {
      model = ref[id];
      ref1 = model._processes;
      for (q = 0, len = ref1.length; q < len; q++) {
        process = ref1[q];
        processes[process.process_id] = {
          value: process,
          force: false
        };
      }
    }
    ref2 = ModelProcessManager._n_processes;
    for (id in ref2) {
      process = ref2[id];
      processes[id] = {
        value: process,
        force: true
      };
    }
    ModelProcessManager._timeout = void 0;
    ModelProcessManager._modlist = {};
    ModelProcessManager._n_processes = {};
    ModelProcessManager._counter += 2;
    for (id in processes) {
      process = processes[id];
      ModelProcessManager._force_m = process.force;
      process.value.onchange();
    }
    return ModelProcessManager._force_m = false;
  };

  return ModelProcessManager;

})();

root = typeof _root_obj === "undefined" ? global : window;

root.SpinalUserManager = (function() {
  function SpinalUserManager() {}

  SpinalUserManager.get_user_id = function(options, user_name, password, success_callback, error_callback) {
    var get_cmd;
    if (error_callback == null) {
      error_callback = null;
    }
    get_cmd = '/get_user_id?u=' + user_name + '&p=' + password;
    return this.send_xhr(options, get_cmd, function(response) {
      if (parseInt(response) === -1) {
        return SpinalUserManager._if_error(error_callback, 'get_user_id', response);
      } else {
        return success_callback(response);
      }
    }, function(status) {
      return SpinalUserManager._if_error(error_callback, 'get_user_id', status);
    });
  };

  SpinalUserManager.get_admin_id = function(options, admin_name, password, success_callback, error_callback) {
    var get_cmd;
    if (error_callback == null) {
      error_callback = null;
    }
    get_cmd = '/get_admin_id?u=' + admin_name + '&p=' + password;
    return this.send_xhr(options, get_cmd, function(response) {
      if (parseInt(response) === -1) {
        return SpinalUserManager._if_error(error_callback, 'get_admin_id', response);
      } else {
        return success_callback(response);
      }
    }, function(status) {
      return SpinalUserManager._if_error(error_callback, 'get_admin_id', status);
    });
  };

  SpinalUserManager.new_account = function(options, user_name, password, success_callback, error_callback) {
    var get_cmd;
    if (error_callback == null) {
      error_callback = null;
    }
    get_cmd = '/get_new_account?e=' + user_name + '&p=' + password + '&cp=' + password;
    return this.send_xhr(options, get_cmd, function(response) {
      if (parseInt(response) === -1) {
        return SpinalUserManager._if_error(error_callback, 'get_new_account', status);
      } else {
        return success_callback(response);
      }
    }, function(status) {
      return SpinalUserManager._if_error(error_callback, 'get_new_account', status);
    });
  };

  SpinalUserManager.change_password = function(options, user_id, password, new_password, success_callback, error_callback) {
    var get_cmd;
    if (error_callback == null) {
      error_callback = null;
    }
    get_cmd = '/get_change_user_password?e=' + user_id + '&op=' + password + '&np=' + new_password + '&cp=' + new_password;
    return this.send_xhr(options, get_cmd, function(response) {
      if (parseInt(response) === -1) {
        return SpinalUserManager._if_error(error_callback, 'get_change_user_password', status);
      } else {
        return success_callback(response);
      }
    }, function(status) {
      return SpinalUserManager._if_error(error_callback, 'get_change_user_password', status);
    });
  };

  SpinalUserManager.delete_account = function(options, user_id, password, success_callback, error_callback) {
    var get_cmd;
    if (error_callback == null) {
      error_callback = null;
    }
    get_cmd = '/get_delete_account?e=' + user_name + '&i=' + user_id + '&p=' + password;
    return this.send_xhr(options, get_cmd, function(response) {
      if (parseInt(response) === -1) {
        return SpinalUserManager._if_error(error_callback, 'get_delete_account', status);
      } else {
        return success_callback(response);
      }
    }, function(status) {
      return SpinalUserManager._if_error(error_callback, 'get_delete_account', status);
    });
  };

  SpinalUserManager.change_password_by_admin = function(options, username, password, admin_id, admin_password, success_callback, error_callback) {
    var get_cmd;
    if (error_callback == null) {
      error_callback = null;
    }
    get_cmd = '/get_change_user_password_by_admin?u=' + username + '&np=' + password + '&a=' + admin_id + '&ap=' + admin_password;
    return this.send_xhr(options, get_cmd, function(response) {
      if (parseInt(response) === -1) {
        return SpinalUserManager._if_error(error_callback, 'get_change_user_password_by_admin', status);
      } else {
        return success_callback(response);
      }
    }, function(status) {
      return SpinalUserManager._if_error(error_callback, 'get_change_user_password_by_admin', status);
    });
  };

  SpinalUserManager.delete_account_by_admin = function(options, username, admin_id, admin_password, success_callback, error_callback) {
    var get_cmd;
    if (error_callback == null) {
      error_callback = null;
    }
    get_cmd = '/get_delete_account_by_admin?u=' + username + '&a=' + admin_id + '&ap=' + admin_password;
    return this.send_xhr(options, get_cmd, function(response) {
      if (parseInt(response) === -1) {
        return SpinalUserManager._if_error(error_callback, 'get_delete_account_by_admin', status);
      } else {
        return success_callback(response);
      }
    }, function(status) {
      return SpinalUserManager._if_error(error_callback, 'get_delete_account_by_admin', status);
    });
  };

  SpinalUserManager.change_account_rights_by_admin = function(options, username, right, admin_id, admin_password, success_callback, error_callback) {
    var get_cmd;
    if (error_callback == null) {
      error_callback = null;
    }
    get_cmd = '/get_change_account_rights_by_admin?u=' + username + '&ri=' + right + '&a=' + admin_id + '&ap=' + admin_password;
    return this.send_xhr(options, get_cmd, function(response) {
      if (parseInt(response) === -1) {
        return SpinalUserManager._if_error(error_callback, 'get_change_account_rights_by_admin', status);
      } else {
        return success_callback(response);
      }
    }, function(status) {
      return SpinalUserManager._if_error(error_callback, 'get_change_account_rights_by_admin', status);
    });
  };

  SpinalUserManager.send_xhr = function(options, get_cmd, success_callback, error_callback) {
    var path, xhr_object;
    path = "";
    if (typeof options === 'string') {
      options = url.parse(options);
    }
    FileSystem._url = options.hostname;
    FileSystem._port = options.port;
    if (FileSystem.CONNECTOR_TYPE === "Node" || FileSystem.is_cordova) {
      if (FileSystem._port) {
        path = "http://" + FileSystem._url + ":" + FileSystem._port + get_cmd;
      } else {
        path = "http://" + FileSystem._url + get_cmd;
      }
    } else if (FileSystem.CONNECTOR_TYPE === "Browser") {
      path = get_cmd;
    }
    xhr_object = FileSystem._my_xml_http_request();
    xhr_object.open('GET', path, true);
    xhr_object.onreadystatechange = function() {
      if (this.readyState === 4 && this.status === 200) {
        return success_callback(this.responseText);
      } else if (this.readyState === 4) {
        return error_callback(this.status);
      }
    };
    return xhr_object.send();
  };

  SpinalUserManager._if_error = function(error_callback, fun, response) {
    if (error_callback !== null) {
      return error_callback(response);
    } else {
      return console.log('Error on ' + fun + ' and the error_callback was not set.');
    }
  };

  return SpinalUserManager;

})();

root = typeof _root_obj === "undefined" ? global : window;

root.Model = (function() {
  function Model(attr) {
    this._attribute_names = [];
    this.model_id = ModelProcessManager._cur_mid;
    ModelProcessManager._cur_mid += 1;
    this._processes = [];
    this._parents = [];
    this._date_last_modification = ModelProcessManager._counter + 2;
    if (attr != null) {
      this._set(attr);
    }
  }

  Model.prototype.destructor = function() {};

  Model.prototype.has_been_modified = function() {
    return this._date_last_modification > ModelProcessManager._counter - 2 || ModelProcessManager._force_m;
  };

  Model.prototype.has_been_directly_modified = function() {
    return this._date_last_modification > ModelProcessManager._counter - 1 || ModelProcessManager._force_m;
  };

  Model.prototype.bind = function(f, onchange_construction) {
    if (onchange_construction == null) {
      onchange_construction = true;
    }
    if (f instanceof Process) {
      this._processes.push(f);
      f._models.push(this);
      if (onchange_construction) {
        ModelProcessManager._n_processes[f.process_id] = f;
        return ModelProcessManager._need_sync_processes();
      }
    } else {
      return new BindProcess(this, onchange_construction, f);
    }
  };

  Model.prototype.unbind = function(f) {
    var len, q, ref, results, v;
    if (f instanceof Process) {
      this._processes.splice(this._processes.indexOf(f), 1);
      return f._models.splice(f._models.indexOf(this), 1);
    } else {
      ref = this._processes;
      results = [];
      for (q = 0, len = ref.length; q < len; q++) {
        v = ref[q];
        if (v instanceof BindProcess && v.f === f) {
          results.push(this.unbind(v));
        }
      }
      return results;
    }
  };

  Model.prototype.get = function() {
    var len, name, q, ref, res;
    res = {};
    ref = this._attribute_names;
    for (q = 0, len = ref.length; q < len; q++) {
      name = ref[q];
      res[name] = this[name].get();
    }
    return res;
  };

  Model.prototype.set = function(value) {
    if (this._set(value)) {
      this._signal_change();
      return true;
    }
    return false;
  };

  Model.prototype.set_state = function(str) {
    var l, len, lst, map, mid, q, s;
    map = {};
    lst = str.split("\n");
    mid = lst.shift();
    for (q = 0, len = lst.length; q < len; q++) {
      l = lst[q];
      if (!l.length) {
        continue;
      }
      s = l.split(" ");
      map[s[0]] = {
        type: s[1],
        data: s[2],
        buff: void 0
      };
    }
    map[mid].buff = this;
    return this._set_state(map[mid].data, map);
  };

  Model.prototype.get_state = function(date) {
    var fmm, id, obj, res;
    if (date == null) {
      date = -1;
    }
    fmm = {};
    this._get_flat_model_map(fmm, date);
    res = this.model_id.toString();
    if (this._date_last_modification > date) {
      for (id in fmm) {
        obj = fmm[id];
        res += "\n" + obj.model_id + " " + ModelProcessManager.get_object_class(obj) + " " + obj._get_state();
      }
    }
    return res;
  };

  Model.prototype.add_attr = function(n, p, signal_change) {
    var key, results, val;
    if (signal_change == null) {
      signal_change = true;
    }
    if (p != null) {
      if (typeof p === "function") {
        return this[n] = p;
      } else {
        if (this[n] != null) {
          console.error(("attribute " + n + " already exists in ") + ("" + (ModelProcessManager.get_object_class(this))));
        }
        p = ModelProcessManager.conv(p);
        if (indexOf.call(p._parents, this) < 0) {
          p._parents.push(this);
        }
        this._attribute_names.push(n);
        this[n] = p;
        if (signal_change) {
          return this._signal_change();
        }
      }
    } else {
      results = [];
      for (key in n) {
        val = n[key];
        if (val != null) {
          results.push(this.add_attr(key, val, signal_change));
        }
      }
      return results;
    }
  };

  Model.prototype.rem_attr = function(name, signal_change) {
    var c, i;
    if (signal_change == null) {
      signal_change = true;
    }
    c = this[name];
    if (c) {
      i = c._parents.indexOf(this);
      if (i >= 0) {
        c._parents.splice(i, 1);
        if (c._parents.length === 0) {
          c.destructor();
        }
      }
      delete this[name];
      i = this._attribute_names.indexOf(name);
      if (i >= 0) {
        this._attribute_names.splice(i, 1);
      }
      if (signal_change) {
        return this._signal_change();
      }
    }
  };

  Model.prototype.mod_attr = function(n, p) {
    if (this[n] !== p) {
      this.rem_attr(n);
      return this.add_attr(n, p);
    }
  };

  Model.prototype.set_attr = function(o) {
    var k, len, q, r, results, to_rem, v;
    for (k in o) {
      v = o[k];
      this.mod_attr(k, v);
    }
    to_rem = (function() {
      var len, q, ref, results;
      ref = this._attribute_names;
      results = [];
      for (q = 0, len = ref.length; q < len; q++) {
        k = ref[q];
        if (o[k] == null) {
          results.push(k);
        }
      }
      return results;
    }).call(this);
    results = [];
    for (q = 0, len = to_rem.length; q < len; q++) {
      r = to_rem[q];
      results.push(this.rem_attr(r));
    }
    return results;
  };

  Model.prototype.size = function(for_display) {
    if (for_display == null) {
      for_display = false;
    }
    return [];
  };

  Model.prototype.dim = function(for_display) {
    if (for_display == null) {
      for_display = false;
    }
    return this.size(for_display).length;
  };

  Model.prototype.equals = function(m) {
    var key, len, len1, q, ref, ref1, u, val, y;
    if (this === m) {
      return true;
    }
    if (m._attribute_names != null) {
      u = {};
      ref = m._attribute_names;
      for (q = 0, len = ref.length; q < len; q++) {
        key = ref[q];
        val = m[key];
        if (this[key] == null) {
          return false;
        }
        if (!this[key].equals(val)) {
          return false;
        }
        u[key] = true;
      }
      ref1 = this._attribute_names;
      for (y = 0, len1 = ref1.length; y < len1; y++) {
        key = ref1[y];
        if (u[key] == null) {
          return false;
        }
      }
    }
    return false;
  };

  Model.prototype.get_parents_that_check = function(func_to_check) {
    var res, visited;
    res = [];
    visited = {};
    this._get_parents_that_check_rec(res, visited, func_to_check);
    return res;
  };

  Model.prototype.deep_copy = function() {
    var key, len, o, q, ref;
    o = {};
    ref = this._attribute_names;
    for (q = 0, len = ref.length; q < len; q++) {
      key = ref[q];
      o[key] = this[key].deep_copy();
    }
    eval("var __new__ = new " + (ModelProcessManager.get_object_class(this)) + ";");
    __new__.set_attr(o);
    return __new__;
  };

  Model.prototype.real_change = function() {
    var a, len, q, ref;
    if (this.has_been_directly_modified() && !this._attribute_names.length) {
      return true;
    }
    ref = this._attribute_names;
    for (q = 0, len = ref.length; q < len; q++) {
      a = ref[q];
      if (typeof this.cosmetic_attribute === "function" ? this.cosmetic_attribute(a) : void 0) {
        continue;
      }
      if (this[a].real_change()) {
        return true;
      }
    }
    return false;
  };

  Model.prototype.cosmetic_attribute = function(name) {
    return false;
  };

  Model.prototype._get_state = function() {
    var name, str;
    str = (function() {
      var len, q, ref, results;
      ref = this._attribute_names;
      results = [];
      for (q = 0, len = ref.length; q < len; q++) {
        name = ref[q];
        results.push(name + ":" + this[name].model_id);
      }
      return results;
    }).call(this);
    return str.join(",");
  };

  Model.prototype._get_fs_data = function(out) {
    var name, obj, str;
    FileSystem.set_server_id_if_necessary(out, this);
    str = (function() {
      var len, q, ref, results;
      ref = this._attribute_names;
      results = [];
      for (q = 0, len = ref.length; q < len; q++) {
        name = ref[q];
        obj = this[name];
        FileSystem.set_server_id_if_necessary(out, obj);
        results.push(name + ":" + obj._server_id);
      }
      return results;
    }).call(this);
    return out.mod += "C " + this._server_id + " " + (str.join(",")) + " ";
  };

  Model.prototype._set = function(value) {
    var change, key, len, len1, q, ref, ref1, used, val, y;
    change = false;
    used = {};
    ref = ModelProcessManager._get_attribute_names(value);
    for (q = 0, len = ref.length; q < len; q++) {
      key = ref[q];
      used[key] = true;
    }
    ref1 = (function() {
      var len1, ref1, results, z;
      ref1 = this._attribute_names;
      results = [];
      for (z = 0, len1 = ref1.length; z < len1; z++) {
        key = ref1[z];
        if (!used[key]) {
          results.push(key);
        }
      }
      return results;
    }).call(this);
    for (y = 0, len1 = ref1.length; y < len1; y++) {
      key = ref1[y];
      change = true;
      this.rem_attr(key, false);
    }
    for (key in value) {
      val = value[key];
      if (val != null) {
        if (this[key] != null) {
          if (this[key].constructor === val.constructor) {
            change |= this[key].set(val);
          } else {
            change = true;
            this.mod_attr(key, val, false);
          }
        } else {
          this.add_attr(key, val, false);
        }
      }
    }
    return change;
  };

  Model.prototype._signal_change = function(change_level) {
    var len, p, q, ref;
    if (change_level == null) {
      change_level = 2;
    }
    if (change_level === 2 && (this._server_id != null)) {
      FileSystem.signal_change(this);
    }
    ModelProcessManager._modlist[this.model_id] = this;
    if (this._date_last_modification <= ModelProcessManager._counter) {
      this._date_last_modification = ModelProcessManager._counter + change_level;
      ref = this._parents;
      for (q = 0, len = ref.length; q < len; q++) {
        p = ref[q];
        p._signal_change(1);
      }
    }
    return ModelProcessManager._need_sync_processes();
  };

  Model.prototype._set_state = function(str, map) {
    var attr, inr, k_id, len, len1, q, ref, ref1, results, spl, u, y;
    u = {};
    if (str.length) {
      ref = str.split(",");
      for (q = 0, len = ref.length; q < len; q++) {
        spl = ref[q];
        inr = spl.split(":");
        attr = inr[0];
        k_id = inr[1];
        u[attr] = true;
        if (map[k_id].buff != null) {
          if (this[attr] == null) {
            this.add_attr(attr, map[k_id].buff);
          } else if (map[k_id].buff !== this[attr]) {
            this.mod_attr(attr, map[k_id].buff);
          }
        } else if (this[attr] == null) {
          this.add_attr(attr, ModelProcessManager._new_model_from_state(k_id, map));
        } else if (!this[attr]._set_state_if_same_type(k_id, map)) {
          this.mod_attr(attr, ModelProcessManager._new_model_from_state(k_id, map));
        }
      }
    }
    ref1 = this._attribute_names;
    results = [];
    for (y = 0, len1 = ref1.length; y < len1; y++) {
      attr = ref1[y];
      if (!u[attr]) {
        results.push(this.rem_attr(attr));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  Model.prototype._get_parents_that_check_rec = function(res, visited, func_to_check) {
    var len, p, q, ref, results;
    if (visited[this.model_id] == null) {
      visited[this.model_id] = true;
      if (func_to_check(this)) {
        return res.push(this);
      } else {
        ref = this._parents;
        results = [];
        for (q = 0, len = ref.length; q < len; q++) {
          p = ref[q];
          results.push(p._get_parents_that_check_rec(res, visited, func_to_check));
        }
        return results;
      }
    }
  };

  Model.prototype._set_state_if_same_type = function(mid, map) {
    var dat;
    dat = map[mid];
    if (ModelProcessManager.get_object_class(this) === dat.type) {
      dat.buff = this;
      this._set_state(dat.data, map);
      return true;
    }
    return false;
  };

  Model.prototype._get_flat_model_map = function(map, date) {
    var len, name, obj, q, ref, results;
    map[this.model_id] = this;
    ref = this._attribute_names;
    results = [];
    for (q = 0, len = ref.length; q < len; q++) {
      name = ref[q];
      obj = this[name];
      if (map[obj.model_id] == null) {
        if (obj._date_last_modification > date) {
          results.push(obj._get_flat_model_map(map, date));
        } else {
          results.push(void 0);
        }
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  return Model;

})();

root = typeof _root_obj === "undefined" ? global : window;

root.Obj = (function(superClass) {
  extend(Obj, superClass);

  function Obj(data) {
    Obj.__super__.constructor.call(this);
    if (data != null) {
      this._set(data);
    }
  }

  Obj.prototype.toString = function() {
    var ref;
    return (ref = this._data) != null ? ref.toString() : void 0;
  };

  Obj.prototype.equals = function(obj) {
    if (obj instanceof Obj) {
      return this._data === obj._data;
    }
    return this._data === obj;
  };

  Obj.prototype.get = function() {
    return this._data;
  };

  Obj.prototype._get_fs_data = function(out) {
    FileSystem.set_server_id_if_necessary(out, this);
    return out.mod += "C " + this._server_id + " " + (this.toString()) + " ";
  };

  Obj.prototype._set = function(value) {
    if (this._data !== value) {
      this._data = value;
      return true;
    }
    return false;
  };

  Obj.prototype._get_state = function() {
    return this._data;
  };

  Obj.prototype._set_state = function(str, map) {
    return this.set(str);
  };

  return Obj;

})(Model);

root = typeof _root_obj === "undefined" ? global : window;

root.Choice = (function(superClass) {
  extend(Choice, superClass);

  function Choice(data, initial_list) {
    if (initial_list == null) {
      initial_list = [];
    }
    Choice.__super__.constructor.call(this);
    this.add_attr({
      num: 0,
      lst: initial_list
    });
    if (data != null) {
      this.num.set(data);
    }
  }

  Choice.prototype.filter = function(obj) {
    return true;
  };

  Choice.prototype.item = function() {
    return this._nlst()[this.num.get()];
  };

  Choice.prototype.get = function() {
    var ref;
    return (ref = this.item()) != null ? ref.get() : void 0;
  };

  Choice.prototype.toString = function() {
    var ref;
    return (ref = this.item()) != null ? ref.toString() : void 0;
  };

  Choice.prototype.equals = function(a) {
    if (a instanceof Choice) {
      return Choice.__super__.equals.call(this, a);
    } else {
      return this._nlst()[this.num.get()].equals(a);
    }
  };

  Choice.prototype._set = function(value) {
    var i, j, len, q, ref;
    ref = this._nlst();
    for (j = q = 0, len = ref.length; q < len; j = ++q) {
      i = ref[j];
      if (i.equals(value)) {
        return this.num.set(j);
      }
    }
    return this.num.set(value);
  };

  Choice.prototype._nlst = function() {
    var l, len, q, ref, results;
    ref = this.lst;
    results = [];
    for (q = 0, len = ref.length; q < len; q++) {
      l = ref[q];
      if (this.filter(l)) {
        results.push(l);
      }
    }
    return results;
  };

  return Choice;

})(Model);

root = typeof _root_obj === "undefined" ? global : window;

root.Bool = (function(superClass) {
  extend(Bool, superClass);

  function Bool(data) {
    Bool.__super__.constructor.call(this);
    this._data = false;
    if (data != null) {
      this._set(data);
    }
  }

  Bool.prototype.toggle = function() {
    return this.set(!this._data);
  };

  Bool.prototype.toBoolean = function() {
    return this._data;
  };

  Bool.prototype.deep_copy = function() {
    return new Bool(this._data);
  };

  Bool.prototype._set = function(value) {
    var n;
    if (n instanceof Model) {
      n = value.toBoolean();
    } else if (value === "false") {
      n = false;
    } else if (value === "true") {
      n = true;
    } else {
      n = Boolean(value);
    }
    if (this._data !== n) {
      this._data = n;
      return true;
    }
    return false;
  };

  Bool.prototype._get_fs_data = function(out) {
    FileSystem.set_server_id_if_necessary(out, this);
    return out.mod += "C " + this._server_id + " " + (1 * Boolean(this._data)) + " ";
  };

  return Bool;

})(Obj);

root = typeof _root_obj === "undefined" ? global : window;

root.ConstOrNotModel = (function(superClass) {
  extend(ConstOrNotModel, superClass);

  function ConstOrNotModel(bool, model, check_disabled) {
    if (check_disabled == null) {
      check_disabled = true;
    }
    ConstOrNotModel.__super__.constructor.call(this);
    this.add_attr({
      bool: bool,
      model: model,
      check_disabled: check_disabled
    });
  }

  ConstOrNotModel.prototype.get = function() {
    var ref;
    return (ref = this.model) != null ? ref.get() : void 0;
  };

  ConstOrNotModel.prototype.set = function(value) {
    var ref;
    return (ref = this.model) != null ? ref.set(value) : void 0;
  };

  ConstOrNotModel.prototype.toString = function() {
    var ref;
    return (ref = this.model) != null ? ref.toString() : void 0;
  };

  return ConstOrNotModel;

})(Model);

root = typeof _root_obj === "undefined" ? global : window;

root.ConstrainedVal = (function(superClass) {
  extend(ConstrainedVal, superClass);

  function ConstrainedVal(value, params) {
    if (params == null) {
      params = {};
    }
    ConstrainedVal.__super__.constructor.call(this);
    this.add_attr({
      val: value || 0,
      _min: params.min != null ? params.min : 0,
      _max: params.max != null ? params.max : 100
    });
    this.add_attr({
      _div: params.div != null ? params.div : this._max - this._min
    });
  }

  ConstrainedVal.prototype.get = function() {
    return this.val.get();
  };

  ConstrainedVal.prototype.ratio = function() {
    return (this.val.get() - this._min.get()) / this.delta();
  };

  ConstrainedVal.prototype.delta = function() {
    return this._max.get() - this._min.get();
  };

  ConstrainedVal.prototype.set_params = function(params) {
    this._min.set(params.min != null ? params.min : 0);
    this._max.set(params.max != null ? params.max : 100);
    return this._div.set(params.div != null ? params.div : this._max - this._min);
  };

  ConstrainedVal.prototype._set = function(value) {
    var res;
    if (value instanceof ConstrainedVal) {
      return this.val._set(value.get());
    }
    res = this.val.set(value);
    this._check_val();
    return res;
  };

  ConstrainedVal.prototype._check_val = function() {
    var d, m, n, r, s, v;
    v = this.val.get();
    m = this._min.get();
    n = this._max.get();
    d = this._div.get();
    if (v < m) {
      this.val.set(m);
    }
    if (v > n) {
      this.val.set(n);
    }
    if (d) {
      s = (n - m) / d;
      r = m + Math.round((this.val.get() - m) / s) * s;
      return this.val.set(r);
    }
  };

  return ConstrainedVal;

})(Model);

root = typeof _root_obj === "undefined" ? global : window;

root.Lst = (function(superClass) {
  extend(Lst, superClass);

  function Lst(data) {
    var d, i, q, ref, s;
    Lst.__super__.constructor.call(this);
    this.length = 0;
    s = this.static_length();
    if (s >= 0) {
      d = this.default_value();
      for (i = q = 0, ref = s; 0 <= ref ? q < ref : q > ref; i = 0 <= ref ? ++q : --q) {
        this.push(d, true);
      }
    }
    if (data != null) {
      this._set(data);
    }
  }

  Lst.prototype.static_length = function() {
    return -1;
  };

  Lst.prototype.default_value = function() {
    return 0;
  };

  Lst.prototype.base_type = function() {
    return void 0;
  };

  Lst.prototype.get = function() {
    var i, len, q, ref, results;
    ref = this;
    results = [];
    for (q = 0, len = ref.length; q < len; q++) {
      i = ref[q];
      results.push(i.get());
    }
    return results;
  };

  Lst.prototype.size = function() {
    return [length];
  };

  Lst.prototype.toString = function() {
    var l, x;
    if (this.length) {
      l = (function() {
        var len, q, ref, results;
        ref = this;
        results = [];
        for (q = 0, len = ref.length; q < len; q++) {
          x = ref[q];
          results.push(x.toString());
        }
        return results;
      }).call(this);
      return l.join();
    } else {
      return "";
    }
  };

  Lst.prototype.equals = function(lst) {
    var i, q, ref;
    if (this.length !== lst.length) {
      return false;
    }
    for (i = q = 0, ref = this.length; 0 <= ref ? q < ref : q > ref; i = 0 <= ref ? ++q : --q) {
      if (!this[i].equals(lst[i])) {
        return false;
      }
    }
    return true;
  };

  Lst.prototype.push = function(value, force) {
    var b;
    if (force == null) {
      force = false;
    }
    if (this._static_size_check(force)) {
      return;
    }
    b = this.base_type();
    if (b != null) {
      if (!(value instanceof b)) {
        value = new b(value);
      }
    } else {
      value = ModelProcessManager.conv(value);
    }
    if (indexOf.call(value._parents, this) < 0) {
      value._parents.push(this);
    }
    this[this.length] = value;
    this.length += 1;
    return this._signal_change();
  };

  Lst.prototype.pop = function() {
    var old;
    if (this._static_size_check(false)) {
      return;
    }
    if (this.length <= 0) {
      return;
    }
    this.length -= 1;
    old = this[this.length];
    this.rem_attr(this.length);
    return old;
  };

  Lst.prototype.clear = function() {
    var results;
    results = [];
    while (this.length) {
      results.push(this.pop());
    }
    return results;
  };

  Lst.prototype.unshift = function(element) {
    var b, i, q, ref;
    if (this._static_size_check(false)) {
      return;
    }
    b = this.base_type();
    if (b != null) {
      if (!(element instanceof b)) {
        element = new b(element);
      }
    } else {
      element = ModelProcessManager.conv(element);
    }
    if (indexOf.call(element._parents, this) < 0) {
      element._parents.push(this);
    }
    if (this.length) {
      for (i = q = ref = this.length - 1; ref <= 0 ? q <= 0 : q >= 0; i = ref <= 0 ? ++q : --q) {
        this[i + 1] = this[i];
      }
    }
    this[0] = element;
    this.length += 1;
    this._signal_change();
    return this.length;
  };

  Lst.prototype.shift = function() {
    var r;
    r = this[0];
    this.splice(0, 1);
    return r;
  };

  Lst.prototype.remove = function(item) {
    var i;
    i = this.indexOf(item);
    if (i >= 0) {
      return this.splice(i, 1);
    }
  };

  Lst.prototype.remove_ref = function(item) {
    var i;
    i = this.indexOf_ref(item);
    if (i >= 0) {
      return this.splice(i, 1);
    }
  };

  Lst.prototype.filter = function(f) {
    var i, len, q, ref, results;
    ref = this;
    results = [];
    for (q = 0, len = ref.length; q < len; q++) {
      i = ref[q];
      if (f(i)) {
        results.push(i);
      }
    }
    return results;
  };

  Lst.prototype.detect = function(f) {
    var i, len, q, ref;
    ref = this;
    for (q = 0, len = ref.length; q < len; q++) {
      i = ref[q];
      if (f(i)) {
        return i;
      }
    }
    return void 0;
  };

  Lst.prototype.sorted = function(fun_sort) {
    var it, len, new_array, q, ref;
    new_array = new Array;
    ref = this;
    for (q = 0, len = ref.length; q < len; q++) {
      it = ref[q];
      new_array.push(it);
    }
    new_array.sort(fun_sort);
    return new_array;
  };

  Lst.prototype.has = function(f) {
    var i, len, q, ref;
    ref = this;
    for (q = 0, len = ref.length; q < len; q++) {
      i = ref[q];
      if (f(i)) {
        return true;
      }
    }
    return false;
  };

  Lst.prototype.indexOf = function(v) {
    var i, q, ref;
    for (i = q = 0, ref = this.length; 0 <= ref ? q < ref : q > ref; i = 0 <= ref ? ++q : --q) {
      if (this[i].equals(v)) {
        return i;
      }
    }
    return -1;
  };

  Lst.prototype.indexOf_ref = function(v) {
    var i, q, ref;
    for (i = q = 0, ref = this.length; 0 <= ref ? q < ref : q > ref; i = 0 <= ref ? ++q : --q) {
      if (this[i] === v) {
        return i;
      }
    }
    return -1;
  };

  Lst.prototype.contains = function(v) {
    return this.indexOf(v) >= 0;
  };

  Lst.prototype.contains_ref = function(v) {
    return this.indexOf_ref(v) >= 0;
  };

  Lst.prototype.toggle = function(v) {
    var i;
    i = this.indexOf(v);
    if (i >= 0) {
      this.splice(i);
      return false;
    } else {
      this.push(v);
      return true;
    }
  };

  Lst.prototype.toggle_ref = function(v) {
    var i;
    i = this.indexOf_ref(v);
    if (i >= 0) {
      this.splice(i);
      return false;
    } else {
      this.push(v);
      return true;
    }
  };

  Lst.prototype.slice = function(begin, end) {
    var i, q, ref, ref1, tab;
    if (end == null) {
      end = this.length;
    }
    if (begin < 0) {
      begin = 0;
    }
    if (end > this.length) {
      end = this.length;
    }
    tab = new Lst;
    for (i = q = ref = begin, ref1 = end; ref <= ref1 ? q < ref1 : q > ref1; i = ref <= ref1 ? ++q : --q) {
      tab.push(this[i].get());
    }
    return tab;
  };

  Lst.prototype.concat = function(new_tab, force) {
    var el, len, q;
    if (force == null) {
      force = false;
    }
    if (this._static_size_check(force)) {
      return;
    }
    if (new_tab.length) {
      for (q = 0, len = new_tab.length; q < len; q++) {
        el = new_tab[q];
        this.push(el);
      }
      return this;
    }
  };

  Lst.prototype.splice = function(index, n) {
    var i, q, ref, ref1, ref2, ref3, ref4, ref5, y, z;
    if (n == null) {
      n = 1;
    }
    if (this._static_size_check(false)) {
      return;
    }
    for (i = q = ref = index, ref1 = Math.min(index + n, this.length); ref <= ref1 ? q < ref1 : q > ref1; i = ref <= ref1 ? ++q : --q) {
      this.rem_attr(i);
    }
    for (i = y = ref2 = index, ref3 = this.length - n; ref2 <= ref3 ? y < ref3 : y > ref3; i = ref2 <= ref3 ? ++y : --y) {
      this[i] = this[i + n];
    }
    for (i = z = ref4 = this.length - n, ref5 = this.length; ref4 <= ref5 ? z < ref5 : z > ref5; i = ref4 <= ref5 ? ++z : --z) {
      delete this[i];
    }
    this.length -= n;
    return this._signal_change();
  };

  Lst.prototype.insert = function(index, list) {
    var i, l, len, len1, o, q, results, y;
    if (list.length) {
      l = Math.max(this.length - index, 0);
      o = (function() {
        var q, ref, results;
        results = [];
        for (i = q = 0, ref = l; 0 <= ref ? q < ref : q > ref; i = 0 <= ref ? ++q : --q) {
          results.push(this.pop());
        }
        return results;
      }).call(this);
      o.reverse();
      for (q = 0, len = list.length; q < len; q++) {
        l = list[q];
        this.push(l);
      }
      results = [];
      for (y = 0, len1 = o.length; y < len1; y++) {
        l = o[y];
        results.push(this.push(l));
      }
      return results;
    }
  };

  Lst.prototype.set_or_push = function(index, val) {
    if (index < this.length) {
      return this.mod_attr(index, val);
    } else if (index === this.length) {
      return this.push(val);
    }
  };

  Lst.prototype.trim = function(size) {
    var results;
    results = [];
    while (this.length > size) {
      results.push(this.pop());
    }
    return results;
  };

  Lst.prototype.join = function(sep) {
    return this.get().join(sep);
  };

  Lst.prototype.deep_copy = function() {
    var i, q, ref, res;
    res = new Lst;
    for (i = q = 0, ref = this.length; 0 <= ref ? q < ref : q > ref; i = 0 <= ref ? ++q : --q) {
      res.push(this[i].deep_copy());
    }
    return res;
  };

  Lst.prototype.back = function() {
    return this[this.length - 1];
  };

  Lst.prototype.real_change = function() {
    var a, len, q, ref;
    if (this.has_been_directly_modified()) {
      return true;
    }
    ref = this;
    for (q = 0, len = ref.length; q < len; q++) {
      a = ref[q];
      if (a.real_change()) {
        return true;
      }
    }
    return false;
  };

  Lst.prototype._set = function(value) {
    var change, p, q, ref, s;
    change = this.length !== value.length;
    s = this.static_length();
    if (s >= 0 && change) {
      console.error("resizing a static array (type " + ((ModelProcessManager.get_object_class(this)) + ") is forbidden"));
    }
    for (p = q = 0, ref = value.length; 0 <= ref ? q < ref : q > ref; p = 0 <= ref ? ++q : --q) {
      if (p < this.length) {
        change |= this[p].set(value[p]);
      } else if (s < 0) {
        this.push(value[p]);
      }
    }
    if (s < 0) {
      while (this.length > value.length) {
        this.pop();
      }
      this.length = value.length;
    }
    return change;
  };

  Lst.prototype._get_flat_model_map = function(map, date) {
    var len, obj, q, ref, results;
    map[this.model_id] = this;
    ref = this;
    results = [];
    for (q = 0, len = ref.length; q < len; q++) {
      obj = ref[q];
      if (map[obj.model_id] == null) {
        if (obj._date_last_modification > date) {
          results.push(obj._get_flat_model_map(map, date));
        } else {
          results.push(void 0);
        }
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  Lst.prototype._get_fs_data = function(out) {
    var obj, str;
    FileSystem.set_server_id_if_necessary(out, this);
    str = (function() {
      var len, q, ref, results;
      ref = this;
      results = [];
      for (q = 0, len = ref.length; q < len; q++) {
        obj = ref[q];
        FileSystem.set_server_id_if_necessary(out, obj);
        results.push(obj._server_id);
      }
      return results;
    }).call(this);
    return out.mod += "C " + this._server_id + " " + (str.join(",")) + " ";
  };

  Lst.prototype._get_state = function() {
    var obj, str;
    str = (function() {
      var len, q, ref, results;
      ref = this;
      results = [];
      for (q = 0, len = ref.length; q < len; q++) {
        obj = ref[q];
        results.push(obj.model_id);
      }
      return results;
    }).call(this);
    return str.join(",");
  };

  Lst.prototype._set_state = function(str, map) {
    var attr, k_id, l_id, q, ref, ref1, ref2, results, y;
    l_id = str.split(",").filter(function(x) {
      return x.length;
    });
    while (this.length > l_id.length) {
      this.pop();
    }
    for (attr = q = 0, ref = this.length; 0 <= ref ? q < ref : q > ref; attr = 0 <= ref ? ++q : --q) {
      k_id = l_id[attr];
      if (map[k_id].buff != null) {
        if (map[k_id].buff !== this[attr]) {
          this.mod_attr(attr, map[k_id].buff);
        }
      } else if (!this[attr]._set_state_if_same_type(k_id, map)) {
        this.mod_attr(attr, ModelProcessManager._new_model_from_state(k_id, map));
      }
    }
    results = [];
    for (attr = y = ref1 = this.length, ref2 = l_id.length; ref1 <= ref2 ? y < ref2 : y > ref2; attr = ref1 <= ref2 ? ++y : --y) {
      k_id = l_id[attr];
      if (map[k_id].buff != null) {
        results.push(this.push(map[k_id].buff));
      } else {
        results.push(this.push(ModelProcessManager._new_model_from_state(k_id, map)));
      }
    }
    return results;
  };

  Lst.prototype._static_size_check = function(force) {
    if (this.static_length() >= 0 && !force) {
      console.error("resizing a static array (type " + ((ModelProcessManager.get_object_class(this)) + ") is forbidden"));
      return true;
    }
    return false;
  };

  return Lst;

})(Model);

root = typeof _root_obj === "undefined" ? global : window;

root.Val = (function(superClass) {
  extend(Val, superClass);

  function Val(data) {
    Val.__super__.constructor.call(this);
    this._data = 0;
    if (data != null) {
      this._set(data);
    }
  }

  Val.prototype.toggle = function() {
    return this.set(!this._data);
  };

  Val.prototype.toBoolean = function() {
    return Boolean(this._data);
  };

  Val.prototype.deep_copy = function() {
    return new Val(this._data);
  };

  Val.prototype.add = function(v) {
    if (v) {
      this._data += v;
      return this._signal_change();
    }
  };

  Val.prototype._set = function(value) {
    var n;
    if (typeof value === "string") {
      if (value.slice(0, 2) === "0x") {
        n = parseInt(value, 16);
      } else {
        n = parseFloat(value);
        if (isNaN(n)) {
          n = parseInt(value);
        }
        if (isNaN(n)) {
          console.log("Don't know how to transform " + value + " to a Val");
        }
      }
    } else if (typeof value === "boolean") {
      n = 1 * value;
    } else if (value instanceof Val) {
      n = value._data;
    } else {
      n = value;
    }
    if (this._data !== n) {
      this._data = n;
      return true;
    }
    return false;
  };

  return Val;

})(Obj);

root = typeof _root_obj === "undefined" ? global : window;

root.Vec = (function(superClass) {
  extend(Vec, superClass);

  function Vec(data) {
    Vec.__super__.constructor.call(this, data);
  }

  Vec.prototype.base_type = function() {
    return Val;
  };

  Vec.prototype._underlying_fs_type = function() {
    return "Lst";
  };

  return Vec;

})(Lst);

root = typeof _root_obj === "undefined" ? global : window;

root.Str = (function(superClass) {
  extend(Str, superClass);

  function Str(data) {
    Str.__super__.constructor.call(this);
    this._data = "";
    this.length = 0;
    if (data != null) {
      this._set(data);
    }
  }

  Str.prototype.toggle = function(str, space) {
    var i, l;
    if (space == null) {
      space = " ";
    }
    l = this._data.split(space);
    i = l.indexOf(str);
    if (i < 0) {
      l.push(str);
    } else {
      l.splice(i, 1);
    }
    return this.set(l.join(" "));
  };

  Str.prototype.contains = function(str) {
    return this._data.indexOf(str) >= 0;
  };

  Str.prototype.equals = function(str) {
    return this._data === str.toString();
  };

  Str.prototype.ends_with = function(str) {
    var l;
    l = this._data.match(str + "$");
    return (l != null ? l.length : void 0) && l[0] === str;
  };

  Str.prototype.deep_copy = function() {
    return new Str(this._data + "");
  };

  Str.prototype._get_fs_data = function(out) {
    FileSystem.set_server_id_if_necessary(out, this);
    return out.mod += "C " + this._server_id + " " + (encodeURI(this._data)) + " ";
  };

  Str.prototype._set = function(value) {
    var n;
    if (value == null) {
      return this._set("");
    }
    n = value.toString();
    if (this._data !== n) {
      this._data = n;
      this.length = this._data.length;
      return true;
    }
    return false;
  };

  Str.prototype._get_state = function() {
    return encodeURI(this._data);
  };

  Str.prototype._set_state = function(str, map) {
    return this.set(decodeURIComponent(str));
  };

  return Str;

})(Obj);

root = typeof _root_obj === "undefined" ? global : window;

root.TypedArray = (function(superClass) {
  extend(TypedArray, superClass);

  function TypedArray(size, data) {
    var B;
    TypedArray.__super__.constructor.call(this);
    if (size == null) {
      size = [];
    }
    if (!size.length) {
      size = [size];
    }
    this._size = size;
    if (data == null) {
      B = this.base_type();
      data = new B(this.nb_items());
    }
    this._data = data;
  }

  TypedArray.prototype.base_type = function() {};

  TypedArray.prototype.dim = function() {
    return this._size.length;
  };

  TypedArray.prototype.size = function(d) {
    if (d != null) {
      return this._size[d];
    } else {
      return this._size;
    }
  };

  TypedArray.prototype.set_val = function(index, value) {
    index = this._get_index(index);
    if (this._data[index] !== value) {
      this._data[index] = value;
      return this._signal_change();
    }
  };

  TypedArray.prototype.nb_items = function() {
    var i, len, q, ref, tot;
    tot = this._size[0] || 0;
    ref = this._size.slice(1);
    for (q = 0, len = ref.length; q < len; q++) {
      i = ref[q];
      tot *= i;
    }
    return tot;
  };

  TypedArray.prototype.toString = function() {
    var i, j, l, len, m, o, q, ref, ref1, res, s, v, y;
    m = 1;
    res = "";
    l = (function() {
      var len, q, ref, results;
      ref = this._size;
      results = [];
      for (q = 0, len = ref.length; q < len; q++) {
        s = ref[q];
        o = m;
        m *= s;
        results.push(o);
      }
      return results;
    }).call(this);
    ref = this._data;
    for (i = q = 0, len = ref.length; q < len; i = ++q) {
      v = ref[i];
      res += v;
      for (j = y = ref1 = l.length - 1; ref1 <= 0 ? y <= 0 : y >= 0; j = ref1 <= 0 ? ++y : --y) {
        if (i % l[j] === l[j] - 1) {
          res += [" ", "\n", "\n\n"][j];
          break;
        }
      }
    }
    return res;
  };

  TypedArray.prototype.equals = function(obj) {
    var i, len, q, ref, v;
    if (obj instanceof TypedArray) {
      if (this._size.length !== obj._size.length) {
        return false;
      }
      ref = this._size;
      for (i = q = 0, len = ref.length; q < len; i = ++q) {
        v = ref[i];
        if (v !== obj._size[i]) {
          return false;
        }
      }
      return this._data === obj._data;
    }
    return this._data === obj;
  };

  TypedArray.prototype.get = function(index) {
    if (index != null) {
      return this._data[this._get_index(index)];
    } else {
      return this._data;
    }
  };

  TypedArray.prototype.resize = function(new_size) {
    var B, len, n, q, s, tot;
    tot = 1;
    for (q = 0, len = new_size.length; q < len; q++) {
      s = new_size[q];
      tot *= s;
    }
    B = this.base_type();
    n = new B(tot);
    n.set(this._data);
    this._data = n;
    this._size = new_size;
    return this._signal_change();
  };

  TypedArray.prototype._set = function(str) {
    var B;
    if (typeof str === "string") {
      this._set_state(str, {});
      return true;
    }
    if (this._data !== str || this._size.length !== 1 || this._size[0] !== str.length) {
      B = this.base_type();
      this._data = new B(str);
      this._size = [str.length];
      return true;
    }
    return false;
  };

  TypedArray.prototype._get_index = function(index) {
    var i, m, o, q, ref;
    if (index.length) {
      o = 0;
      m = 1;
      for (i = q = 0, ref = index.length; 0 <= ref ? q < ref : q > ref; i = 0 <= ref ? ++q : --q) {
        o += m * index[i];
        m *= this._size[i];
      }
      return o;
    }
    return index;
  };

  TypedArray.prototype._get_fs_data = function(out) {
    FileSystem.set_server_id_if_necessary(out, this);
    return out.mod += "C " + this._server_id + " " + (this._get_state()) + " ";
  };

  TypedArray.prototype._get_state = function() {
    var d, len, len1, q, ref, ref1, res, s, y;
    res = "";
    res += this._size.length;
    ref = this._size;
    for (q = 0, len = ref.length; q < len; q++) {
      s = ref[q];
      res += "," + s;
    }
    ref1 = this._data;
    for (y = 0, len1 = ref1.length; y < len1; y++) {
      d = ref1[y];
      res += "," + d;
    }
    return res;
  };

  TypedArray.prototype._set_state = function(str, map) {
    var B, l, n, q, ref, results, s, v;
    l = str.split(",");
    s = parseInt(l[0]);
    this._size = (function() {
      var q, ref, results;
      results = [];
      for (v = q = 0, ref = s; 0 <= ref ? q < ref : q > ref; v = 0 <= ref ? ++q : --q) {
        results.push(parseInt(l[v + 1]));
      }
      return results;
    })();
    B = this.base_type();
    n = this.nb_items();
    this._data = new B(n);
    results = [];
    for (v = q = 0, ref = n; 0 <= ref ? q < ref : q > ref; v = 0 <= ref ? ++q : --q) {
      results.push(this._data[v] = parseFloat(l[s + 1 + v]));
    }
    return results;
  };

  return TypedArray;

})(Model);

root = typeof _root_obj === "undefined" ? global : window;

root.TypedArray_Float32 = (function(superClass) {
  extend(TypedArray_Float32, superClass);

  function TypedArray_Float32(size, data) {
    if (size == null) {
      size = [];
    }
    TypedArray_Float32.__super__.constructor.call(this, size, data);
  }

  TypedArray_Float32.prototype.base_type = function() {
    return Float32Array;
  };

  TypedArray_Float32.prototype.deep_copy = function() {
    return new TypedArray_Float32(this._size, this._data);
  };

  return TypedArray_Float32;

})(TypedArray);

root = typeof _root_obj === "undefined" ? global : window;

root.TypedArray_Float64 = (function(superClass) {
  extend(TypedArray_Float64, superClass);

  function TypedArray_Float64(size, data) {
    if (size == null) {
      size = [];
    }
    TypedArray_Float64.__super__.constructor.call(this, size, data);
  }

  TypedArray_Float64.prototype.base_type = function() {
    return Float64Array;
  };

  TypedArray_Float64.prototype.deep_copy = function() {
    return new TypedArray_Float64(this._size, this._data);
  };

  return TypedArray_Float64;

})(TypedArray);

root = typeof _root_obj === "undefined" ? global : window;

root.TypedArray_Int32 = (function(superClass) {
  extend(TypedArray_Int32, superClass);

  function TypedArray_Int32(size, data) {
    if (size == null) {
      size = [];
    }
    TypedArray_Int32.__super__.constructor.call(this, size, data);
  }

  TypedArray_Int32.prototype.base_type = function() {
    return Int32Array;
  };

  TypedArray_Int32.prototype.deep_copy = function() {
    return new TypedArray_Int32(this._size, this._data);
  };

  return TypedArray_Int32;

})(TypedArray);

root = typeof _root_obj === "undefined" ? global : window;

root.User = (function(superClass) {
  extend(User, superClass);

  function User() {
    User.__super__.constructor.call(this);
  }

  return User;

})(Model);

root = typeof _root_obj === "undefined" ? global : window;

root.FileSystem = (function() {
  var XMLHttpRequest_node;

  FileSystem.popup = 0;

  FileSystem.debug = false;

  FileSystem._cur_tmp_server_id = 0;

  FileSystem._sig_server = true;

  FileSystem._disp = false;

  FileSystem._userid = "644";

  FileSystem._timeout_reconnect = 30000;

  if (typeof document !== "undefined") {
    FileSystem.is_cordova = document.URL.indexOf('http://') === -1 && document.URL.indexOf('https://') === -1;
  } else {
    FileSystem.is_cordova = false;
  }

  if (typeof global !== 'undefined') {
    XMLHttpRequest_node = require('xhr2');
    FileSystem._XMLHttpRequest = XMLHttpRequest_node;
  }

  FileSystem._objects_to_send = {};

  FileSystem._timer_send = void 0;

  FileSystem._timer_chan = void 0;

  FileSystem._nb_callbacks = 0;

  FileSystem._callbacks = {};

  FileSystem._type_callbacks = [];

  FileSystem._nb_insts = 0;

  FileSystem._insts = {};

  FileSystem._files_to_upload = {};

  FileSystem._ptr_to_update = {};

  FileSystem._tmp_objects = {};

  FileSystem._objects = {};

  FileSystem._url = "127.0.0.1";

  FileSystem._port = "8888";

  FileSystem.url_com = "/sceen/_";

  FileSystem.url_upload = "/sceen/upload";

  if (typeof global !== 'undefined') {
    FileSystem.CONNECTOR_TYPE = "Node";
  } else {
    FileSystem.CONNECTOR_TYPE = "Browser";
  }

  function FileSystem() {
    this._data_to_send = "";
    this._session_num = -2;
    this._num_inst = FileSystem._nb_insts++;
    this.make_channel_error_timer = 0;
    FileSystem._insts[this._num_inst] = this;
    if (FileSystem._userid != null) {
      this.send("U " + FileSystem._userid + " " + FileSystem._password + " ");
    }
    this.send("S " + this._num_inst + " ");
  }

  FileSystem.prototype.load = function(path, callback) {
    FileSystem._send_chan();
    this.send("L " + FileSystem._nb_callbacks + " " + (encodeURI(path)) + " ");
    FileSystem._callbacks[FileSystem._nb_callbacks] = callback;
    return FileSystem._nb_callbacks++;
  };

  FileSystem.prototype.load_type = function(type, callback) {
    FileSystem._send_chan();
    this.send("R 0 " + type + " ");
    return FileSystem._type_callbacks.push([type, callback]);
  };

  FileSystem.prototype.load_or_make_dir = function(dir, callback) {
    return this.load(dir, (function(_this) {
      return function(res, err) {
        var lst, nir, oir, v;
        if (err) {
          if (dir === "/") {
            return callback(0, err);
          } else {
            lst = (function() {
              var len, q, ref, results;
              ref = dir.split('/');
              results = [];
              for (q = 0, len = ref.length; q < len; q++) {
                v = ref[q];
                if (v.length) {
                  results.push(v);
                }
              }
              return results;
            })();
            nir = lst.pop();
            oir = "/" + lst.join("/");
            return _this.load_or_make_dir(oir, function(n_res, n_err) {
              var n_dir;
              if (n_err) {
                return callback(0, n_err);
              } else {
                n_dir = new Directory;
                n_res.add_file(nir, n_dir);
                return callback(n_dir, n_err);
              }
            });
          }
        } else {
          return callback(res, err);
        }
      };
    })(this));
  };

  FileSystem.prototype.load_ptr = function(ptr, callback) {
    FileSystem._send_chan();
    this.send("l " + FileSystem._nb_callbacks + " " + ptr + " ");
    FileSystem._callbacks[FileSystem._nb_callbacks] = callback;
    return FileSystem._nb_callbacks++;
  };

  FileSystem.prototype.load_right = function(ptr, callback) {
    FileSystem._send_chan();
    this.send("r " + ptr + " " + FileSystem._nb_callbacks + " ");
    FileSystem._callbacks[FileSystem._nb_callbacks] = callback;
    return FileSystem._nb_callbacks++;
  };

  FileSystem.prototype.share_model = function(ptr, file_name, share_type, targetName) {
    FileSystem._send_chan();
    return this.send("h " + ptr._server_id + " " + share_type + " " + (encodeURI(targetName)) + " " + (encodeURI(file_name)) + " ");
  };

  FileSystem.prototype.send = function(data) {
    this._data_to_send += data;
    if (FileSystem._timer_send == null) {
      return FileSystem._timer_send = setTimeout(FileSystem._timeout_send_func, 1);
    }
  };

  FileSystem.prototype.make_channel = function() {
    var path, xhr_object;
    path = "";
    if (FileSystem.CONNECTOR_TYPE === "Node" || FileSystem.is_cordova) {
      if (FileSystem._port) {
        path = "http://" + FileSystem._url + ":" + FileSystem._port + FileSystem.url_com + ("?s=" + this._session_num);
      } else {
        path = "http://" + FileSystem._url + FileSystem.url_com + ("?s=" + this._session_num);
      }
    } else if (FileSystem.CONNECTOR_TYPE === "Browser") {
      path = FileSystem.url_com + ("?s=" + this._session_num);
    }
    xhr_object = FileSystem._my_xml_http_request();
    xhr_object.open('GET', path, true);
    xhr_object.onreadystatechange = function() {
      var _fs, _w;
      if (this.readyState === 4 && this.status === 200) {
        _fs = FileSystem.get_inst();
        if (_fs.make_channel_error_timer !== 0) {
          _fs.onConnectionError(0);
        }
        _fs.make_channel_error_timer = 0;
        if (FileSystem._disp) {
          console.log("chan ->", this.responseText);
        }
        _w = function(sid, obj) {
          var _obj, c, len, q, ref, results;
          _obj = FileSystem._create_model_by_name(obj);
          if ((sid != null) && (_obj != null)) {
            _obj._server_id = sid;
            FileSystem._objects[sid] = _obj;
            ref = FileSystem._type_callbacks;
            results = [];
            for (q = 0, len = ref.length; q < len; q++) {
              c = ref[q];
              if (_obj instanceof root[c[0]]) {
                results.push(c[1](_obj));
              } else {
                results.push(void 0);
              }
            }
            return results;
          }
        };
        FileSystem._sig_server = false;
        eval(this.responseText);
        return FileSystem._sig_server = true;
      } else if (this.readyState === 4 && this.status === 0) {
        console.error("Disconnected form the server with request : " + path + ".");
        _fs = FileSystem.get_inst();
        if (_fs.make_channel_error_timer === 0) {
          console.log("Trying to reconnect.");
          _fs.make_channel_error_timer = new Date();
          setTimeout(_fs.make_channel.bind(_fs), 1000);
          return _fs.onConnectionError(1);
        } else if (((new Date()) - _fs.make_channel_error_timer) < FileSystem._timeout_reconnect) {
          return setTimeout(_fs.make_channel.bind(_fs), 1000);
        } else {
          return _fs.onConnectionError(2);
        }
      } else if (this.readyState === 4 && this.status === 500) {
        return FileSystem.get_inst().onConnectionError(3);
      }
    };
    return xhr_object.send();
  };

  FileSystem.prototype.onConnectionError = function(error_code) {
    var msg;
    msg = "";
    if (error_code === 0) {
      if (FileSystem.CONNECTOR_TYPE === "Browser" || FileSystem.is_cordova) {
        FileSystem.popup.hide();
      } else {
        console.log("Reconnected to the server.");
      }
    } else if (error_code === 1) {
      if (FileSystem.CONNECTOR_TYPE === "Browser" || FileSystem.is_cordova) {
        msg = "Disconnected form the server, trying to reconnect...";
      } else {
        console.error("Disconnected form the server, trying to reconnect...");
      }
    } else if (error_code === 2 || error_code === 3 || error_code === 4) {
      if (FileSystem.CONNECTOR_TYPE === "Browser" || FileSystem.is_cordova) {
        msg = "Disconnected form the server, please refresh the window.";
      } else if (FileSystem.CONNECTOR_TYPE === "Node") {
        console.error("Disconnected form the server.");
        process.exit();
      } else {
        console.error("Disconnected form the server.");
      }
    }
    if (msg !== "") {
      if (FileSystem.popup === 0) {
        FileSystem.popup = new new_alert_msg({
          parent: document.getElementsByTagName("BODY")[0],
          msg: msg,
          btn: [
            {
              txt: 'reload page',
              click: window.location.reload.bind(window.location),
              backgroundColor: '#ff5b57'
            }, {
              txt: 'close',
              backgroundColor: '#348fe2',
              click: function() {
                return FileSystem.popup.hide();
              }
            }
          ]
        });
      } else {
        FileSystem.popup.show();
      }
      if (error_code === 2 || error_code === 3 || error_code === 4) {
        FileSystem.popup.show_btn();
      } else {
        FileSystem.popup.hide_btn();
      }
      return FileSystem.popup.setMsg(msg);
    }
  };

  FileSystem.get_inst = function() {
    var i, k, ref;
    ref = FileSystem._insts;
    for (k in ref) {
      i = ref[k];
      return i;
    }
    return new FileSystem;
  };

  FileSystem.set_server_id_if_necessary = function(out, obj) {
    var ncl;
    if (obj._server_id == null) {
      obj._server_id = FileSystem._get_new_tmp_server_id();
      FileSystem._tmp_objects[obj._server_id] = obj;
      ncl = ModelProcessManager.get_object_class(obj);
      if (obj._underlying_fs_type != null) {
        out.mod += "T " + obj._server_id + " " + ncl + " ";
        ncl = obj._underlying_fs_type();
      }
      out.cre += "N " + obj._server_id + " " + ncl + " ";
      return obj._get_fs_data(out);
    }
  };

  FileSystem.signal_change = function(m) {
    if (FileSystem._sig_server) {
      FileSystem._objects_to_send[m.model_id] = m;
      if (FileSystem._timer_chan != null) {
        clearTimeout(FileSystem._timer_chan);
      }
      return FileSystem._timer_chan = setTimeout(FileSystem._timeout_chan_func, 250);
    }
  };

  FileSystem._tmp_id_to_real = function(tmp_id, res) {
    var fs, path, ptr, tmp, xhr_object;
    tmp = FileSystem._tmp_objects[tmp_id];
    if (tmp == null) {
      console.log(tmp_id);
    }
    FileSystem._objects[res] = tmp;
    tmp._server_id = res;
    delete FileSystem._tmp_objects[tmp_id];
    ptr = FileSystem._ptr_to_update[tmp_id];
    if (ptr != null) {
      delete FileSystem._ptr_to_update[tmp_id];
      ptr.data.value = res;
    }
    if ((FileSystem._files_to_upload[tmp_id] != null) && (tmp.file != null)) {
      delete FileSystem._files_to_upload[tmp_id];
      fs = FileSystem.get_inst();
      path = "";
      if (FileSystem.CONNECTOR_TYPE === "Node" || FileSystem.is_cordova) {
        if (FileSystem._port) {
          path = "http://" + FileSystem._url + ":" + FileSystem._port + FileSystem.url_com + ("?s=" + fs._session_num + "&p=" + tmp._server_id);
        } else {
          path = "http://" + FileSystem._url + FileSystem.url_com + ("?s=" + fs._session_num + "&p=" + tmp._server_id);
        }
      } else if (FileSystem.CONNECTOR_TYPE === "Browser") {
        path = FileSystem.url_com + ("?s=" + fs._session_num + "&p=" + tmp._server_id);
      }
      xhr_object = FileSystem._my_xml_http_request();
      xhr_object.open('PUT', path, true);
      xhr_object.onreadystatechange = function() {
        var _w;
        if (this.readyState === 4 && this.status === 200) {
          _w = function(sid, obj) {
            var _obj;
            _obj = FileSystem._create_model_by_name(obj);
            if ((sid != null) && (_obj != null)) {
              _obj._server_id = sid;
              return FileSystem._objects[sid] = _obj;
            }
          };
          return eval(this.responseText);
        }
      };
      xhr_object.send(tmp.file);
      delete tmp.file;
    }
    return FileSystem.signal_change(FileSystem._objects[res]);
  };

  FileSystem._create_model_by_name = function(name) {
    if (typeof name !== "string") {
      return name;
    }
    if (typeof spinalCore._def[name] !== 'undefined') {
      return new spinalCore._def[name]();
    }
    if (typeof root[name] === 'undefined') {
      if (FileSystem.debug === true) {
        console.warn("Got Model type \"" + name + "\" from hub but no registered.");
      }
      root[name] = new Function("return function " + name + " (){" + name + ".super(this);}")();
      FileSystem.extend(root[name], Model);
    }
    return new root[name]();
  };

  FileSystem.extend = function(child, parent) {
    var child_name, ctor, key, value;
    for (key in parent) {
      value = parent[key];
      child[key] = value;
    }
    ctor = function() {
      this.constructor = child;
    };
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
    child.__super__ = parent.prototype;
    child.super = function () {
            var args = [];
           	for (var i=1; i < arguments.length; i++)
                args[i-1] = arguments[i];
            child.__super__.constructor.apply(arguments[0], args);
        };
    root = typeof global !== "undefined" && global !== null ? global : window;
    child_name = /^function\s+([\w\$]+)\s*\(/.exec(child.toString())[1];
    return root[child_name] = child;
  };

  FileSystem._get_new_tmp_server_id = function() {
    FileSystem._cur_tmp_server_id++;
    if (FileSystem._cur_tmp_server_id % 4 === 0) {
      FileSystem._cur_tmp_server_id++;
    }
    return FileSystem._cur_tmp_server_id;
  };

  FileSystem._send_chan = function() {
    var f, k, out, ref, results;
    out = FileSystem._get_chan_data();
    ref = FileSystem._insts;
    results = [];
    for (k in ref) {
      f = ref[k];
      results.push(f.send(out));
    }
    return results;
  };

  FileSystem._timeout_chan_func = function() {
    FileSystem._send_chan();
    return delete FileSystem._timer_chan;
  };

  FileSystem._get_chan_data = function() {
    var model, n, out, ref;
    out = {
      cre: "",
      mod: ""
    };
    ref = FileSystem._objects_to_send;
    for (n in ref) {
      model = ref[n];
      model._get_fs_data(out);
    }
    FileSystem._objects_to_send = {};
    return out.cre + out.mod;
  };

  FileSystem._timeout_send_func = function() {
    var f, k, out, path, ref, ref1, xhr_object;
    out = FileSystem._get_chan_data();
    ref = FileSystem._insts;
    for (k in ref) {
      f = ref[k];
      f._data_to_send += out;
    }
    ref1 = FileSystem._insts;
    for (k in ref1) {
      f = ref1[k];
      if (!f._data_to_send.length) {
        continue;
      }
      if (f._session_num === -1) {
        continue;
      }
      if (f._session_num === -2) {
        f._session_num = -1;
      } else {
        f._data_to_send = ("s " + f._session_num + " ") + f._data_to_send;
      }
      path = "";
      if (FileSystem.CONNECTOR_TYPE === "Node" || FileSystem.is_cordova) {
        if (FileSystem._port) {
          path = "http://" + FileSystem._url + ":" + FileSystem._port + FileSystem.url_com;
        } else {
          path = "http://" + FileSystem._url + FileSystem.url_com;
        }
      } else if (FileSystem.CONNECTOR_TYPE === "Browser") {
        path = FileSystem.url_com;
      }
      xhr_object = FileSystem._my_xml_http_request();
      xhr_object.open('POST', path, true);
      xhr_object.onreadystatechange = function() {
        var _c, _w, c, len, q, results;
        if (this.readyState === 4 && this.status === 200) {
          if (FileSystem._disp) {
            console.log("resp ->", this.responseText);
          }
          _c = [];
          _w = function(sid, obj) {
            var _obj, c, len, q, ref2, results;
            _obj = FileSystem._create_model_by_name(obj);
            if ((sid != null) && (_obj != null)) {
              _obj._server_id = sid;
              FileSystem._objects[sid] = _obj;
              ref2 = FileSystem._type_callbacks;
              results = [];
              for (q = 0, len = ref2.length; q < len; q++) {
                c = ref2[q];
                if (_obj instanceof root[c[0]]) {
                  results.push(c[1](_obj));
                } else {
                  results.push(void 0);
                }
              }
              return results;
            }
          };
          FileSystem._sig_server = false;
          eval(this.responseText);
          FileSystem._sig_server = true;
          results = [];
          for (q = 0, len = _c.length; q < len; q++) {
            c = _c[q];
            results.push(FileSystem._callbacks[c[0]](FileSystem._objects[c[1]], c[2]));
          }
          return results;
        } else if (this.readyState === 4 && (this.status === 0 || this.status === 500)) {
          return FileSystem.get_inst().onConnectionError(4);
        }
      };
      if (FileSystem._disp) {
        console.log("sent ->", f._data_to_send + "E ");
      }
      xhr_object.setRequestHeader('Content-Type', 'text/plain');
      xhr_object.send(f._data_to_send + "E ");
      f._data_to_send = "";
    }
    FileSystem._objects_to_send = {};
    return delete FileSystem._timer_send;
  };

  FileSystem._my_xml_http_request = function() {
    if (FileSystem.CONNECTOR_TYPE === "Browser") {
      if (window.XMLHttpRequest) {
        return new XMLHttpRequest;
      }
      if (window.ActiveXObject) {
        return new ActiveXObject('Microsoft.XMLHTTP');
      }
      return alert('Your browser does not seem to support XMLHTTPRequest objects...');
    } else if (FileSystem.CONNECTOR_TYPE === "Node") {
      return new FileSystem._XMLHttpRequest();
    } else {
      return console.log("you must define CONNECTOR_TYPE");
    }
  };

  return FileSystem;

})();

root = typeof _root_obj === "undefined" ? global : window;

root.Directory = (function(superClass) {
  extend(Directory, superClass);

  function Directory() {
    Directory.__super__.constructor.call(this);
  }

  Directory.prototype.base_type = function() {
    return File;
  };

  Directory.prototype.find = function(name) {
    var f, len, q, ref;
    ref = this;
    for (q = 0, len = ref.length; q < len; q++) {
      f = ref[q];
      if (f.name.equals(name)) {
        return f;
      }
    }
    return void 0;
  };

  Directory.prototype.load = function(name, callback) {
    var f;
    f = this.find(name);
    if (f) {
      return f.load(callback);
    } else {
      return callback(void 0, "file does not exist");
    }
  };

  Directory.prototype.has = function(name) {
    var f, len, q, ref;
    ref = this;
    for (q = 0, len = ref.length; q < len; q++) {
      f = ref[q];
      if (f.name.equals(name)) {
        return true;
      }
    }
    return false;
  };

  Directory.prototype.add_file = function(name, obj, params) {
    var o, res;
    if (params == null) {
      params = {};
    }
    o = this.find(name);
    if (o != null) {
      return o;
    }
    res = new File(name, obj, params);
    this.push(res);
    return res;
  };

  Directory.prototype.add_tiff_file = function(name, obj, tiff_obj, params) {
    var o, res;
    if (params == null) {
      params = {};
    }
    o = this.find(name);
    if (o != null) {
      return o;
    }
    res = new TiffFile(name, obj, tiff_obj, params);
    this.push(res);
    return res;
  };

  Directory.prototype.force_add_file = function(name, obj, params) {
    var name_file, num, o, res;
    if (params == null) {
      params = {};
    }
    num = 0;
    name_file = name;
    o = this.find(name_file);
    if (o != null) {
      while (true) {
        name_file = name + "_" + num;
        o = this.find(name_file);
        if (o != null) {
          num += 1;
        } else {
          break;
        }
      }
    }
    res = new File(name_file, obj, params);
    this.push(res);
    return res;
  };

  Directory.prototype.get_file_info = function(info) {
    return info.icon = "folder";
  };

  return Directory;

})(Lst);

root = typeof _root_obj === "undefined" ? global : window;

root.File = (function(superClass) {
  extend(File, superClass);

  function File(name, ptr_or_model, info) {
    var cp_info, key, val;
    if (name == null) {
      name = "";
    }
    if (ptr_or_model == null) {
      ptr_or_model = 0;
    }
    if (info == null) {
      info = {};
    }
    File.__super__.constructor.call(this);
    cp_info = {};
    for (key in info) {
      val = info[key];
      cp_info[key] = val;
    }
    if (ptr_or_model instanceof Model) {
      if (cp_info.model_type == null) {
        cp_info.model_type = ModelProcessManager.get_object_class(ptr_or_model);
      }
      if (typeof ptr_or_model.get_file_info === "function") {
        ptr_or_model.get_file_info(cp_info);
      }
    }
    this.add_attr({
      name: name,
      admins: new Lst,
      users: new Lst,
      _created_at: new Date(),
      _ptr: new Ptr(ptr_or_model),
      _info: cp_info
    });
  }

  File.prototype.load = function(callback) {
    return this._ptr.load(callback);
  };

  return File;

})(Model);

root = typeof _root_obj === "undefined" ? global : window;

root.Path = (function(superClass) {
  extend(Path, superClass);

  function Path(file1) {
    var size;
    this.file = file1;
    Path.__super__.constructor.call(this);
    size = this.file != null ? this.file.fileSize != null ? this.file.fileSize : this.file.size : 0;
    this.add_attr({
      remaining: size,
      to_upload: size
    });
  }

  Path.prototype.get_file_info = function(info) {
    info.remaining = this.remaining;
    return info.to_upload = this.to_upload;
  };

  Path.prototype._get_fs_data = function(out) {
    Path.__super__._get_fs_data.call(this, out);
    if ((this.file != null) && this._server_id & 3) {
      return FileSystem._files_to_upload[this._server_id] = this;
    }
  };

  return Path;

})(Model);

root = typeof _root_obj === "undefined" ? global : window;

root.Ptr = (function(superClass) {
  extend(Ptr, superClass);

  function Ptr(model) {
    Ptr.__super__.constructor.call(this);
    this.data = {};
    this._set(model);
  }

  Ptr.prototype.load = function(callback) {
    var ref;
    if (this.data.model != null) {
      return callback(this.data.model, false);
    } else {
      return (ref = FileSystem.get_inst()) != null ? ref.load_ptr(this.data.value, callback) : void 0;
    }
  };

  Ptr.prototype._get_fs_data = function(out) {
    FileSystem.set_server_id_if_necessary(out, this);
    if (this.data.model != null) {
      FileSystem.set_server_id_if_necessary(out, this.data.model);
      out.mod += "C " + this._server_id + " " + this.data.model._server_id + " ";
      this.data.value = this.data.model._server_id;
      if (this.data.model._server_id & 3) {
        return FileSystem._ptr_to_update[this.data.model._server_id] = this;
      }
    } else {
      return out.mod += "C " + this._server_id + " " + this.data.value + " ";
    }
  };

  Ptr.prototype._set = function(model) {
    var res;
    if (typeof model === "number") {
      res = this.data.value !== model;
      this.data = {
        value: model
      };
      return res;
    }
    if (model instanceof Model) {
      res = this.data.value !== model._server_id;
      this.data = {
        model: model,
        value: model._server_id
      };
      return res;
    }
    return false;
  };

  Ptr.prototype._get_state = function() {
    return this._data;
  };

  Ptr.prototype._set_state = function(str, map) {
    return this.set(str);
  };

  return Ptr;

})(Model);

root = typeof _root_obj === "undefined" ? global : window;

root.RightsItem = (function(superClass) {
  extend(RightsItem, superClass);

  function RightsItem() {
    RightsItem.__super__.constructor.call(this);
  }

  return RightsItem;

})(Lst);

root = typeof _root_obj === "undefined" ? global : window;

root.SessionModel = (function(superClass) {
  extend(SessionModel, superClass);

  function SessionModel() {
    SessionModel.__super__.constructor.call(this);
  }

  return SessionModel;

})(Model);

root = typeof _root_obj === "undefined" ? global : window;

root.TiffFile = (function(superClass) {
  extend(TiffFile, superClass);

  function TiffFile(name, ptr_or_model, ptr_tiff, info) {
    if (name == null) {
      name = "";
    }
    if (ptr_or_model == null) {
      ptr_or_model = 0;
    }
    if (ptr_tiff == null) {
      ptr_tiff = 0;
    }
    if (info == null) {
      info = {};
    }
    TiffFile.__super__.constructor.call(this, name, ptr_or_model, info);
    this.add_attr({
      _ptr_tiff: new Ptr(ptr_tiff),
      _has_been_converted: 0
    });
  }

  TiffFile.prototype.load_tiff = function(callback) {
    return this._ptr_tiff.load(callback);
  };

  return TiffFile;

})(File);

root = typeof _root_obj === "undefined" ? global : window;

root.UserRight = (function(superClass) {
  extend(UserRight, superClass);

  function UserRight() {
    UserRight.__super__.constructor.call(this);
  }

  UserRight.prototype.set = function() {
    return console.log("Set a UserRight is not allowed.");
  };

  return UserRight;

})(Model);

root = typeof _root_obj === "undefined" ? global : window;

root.RightSetList = (function(superClass) {
  extend(RightSetList, superClass);

  function RightSetList() {
    RightSetList.__super__.constructor.call(this);
  }

  return RightSetList;

})(Lst);

root = typeof _root_obj === "undefined" ? global : window;

root.Process = (function() {
  function Process(m, onchange_construction) {
    var i, len, q;
    if (onchange_construction == null) {
      onchange_construction = true;
    }
    this.process_id = ModelProcessManager._cur_process_id;
    ModelProcessManager._cur_process_id += 1;
    this._models = [];
    if (m instanceof Model) {
      m.bind(this, onchange_construction);
    } else if (m.length != null) {
      for (q = 0, len = m.length; q < len; q++) {
        i = m[q];
        i.bind(this, onchange_construction);
      }
    } else if (m != null) {
      console.error("Process constructor doesn't know what to do with", m);
    }
  }

  Process.prototype.destructor = function() {
    var i, len, m, q, ref, results;
    ref = this._models;
    results = [];
    for (q = 0, len = ref.length; q < len; q++) {
      m = ref[q];
      i = m._processes.indexOf(this);
      if (i >= 0) {
        results.push(m._processes.splice(i, 1));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  Process.prototype.onchange = function() {};

  return Process;

})();

root.bind = function(m, f) {
  var i, len, q, results;
  if (m instanceof Model) {
    return m.bind(f);
  } else {
    results = [];
    for (q = 0, len = m.length; q < len; q++) {
      i = m[q];
      results.push(i.bind(f));
    }
    return results;
  }
};

root = typeof _root_obj === "undefined" ? global : window;

root.BindProcess = (function(superClass) {
  extend(BindProcess, superClass);

  function BindProcess(model, onchange_construction, f1) {
    this.f = f1;
    BindProcess.__super__.constructor.call(this, model, onchange_construction);
  }

  BindProcess.prototype.onchange = function() {
    return this.f();
  };

  return BindProcess;

})(Process);

new_dom_element = function(params, nodeName) {
  var k, n, name, v, val;
  if (params == null) {
    params = {};
  }
  if (nodeName == null) {
    nodeName = "div";
  }
  n = document.createElement(params.nodeName || nodeName);
  for (name in params) {
    val = params[name];
    switch (name) {
      case "parentNode":
        val.appendChild(n);
        break;
      case "nodeName":
        void 0;
        break;
      case "style":
        for (k in val) {
          v = val[k];
          n.style[k] = v;
        }
        break;
      case "txt":
        n.innerHTML = val;
        break;
      default:
        n[name] = val;
    }
  }
  return n;
};

add_class = function(obj, src) {
  var old, p_1;
  if (typeof src === "string") {
    return add_class(obj, src.split(" "));
  }
  old = (obj.className || "").split(" ");
  p_1 = src.filter(function(x) {
    return indexOf.call(old, x) < 0;
  });
  return obj.className = (old.concat(p_1)).filter(function(x) {
    return x;
  }).join(" ");
};

rem_class = function(obj, src) {
  var old;
  if (typeof src === "string") {
    return rem_class(obj, src.split(" "));
  }
  old = (obj.className || "").split(" ");
  return obj.className = (old.filter(function(x) {
    return indexOf.call(src, x) < 0;
  })).join(" ");
};

get_left = function(l) {
  if (l.offsetParent != null) {
    return l.offsetLeft + get_left(l.offsetParent);
  } else {
    return l.offsetLeft;
  }
};

get_top = function(l) {
  if (l.offsetParent != null) {
    return l.offsetTop + get_top(l.offsetParent);
  } else {
    return l.offsetTop;
  }
};

new_alert_msg = (function() {
  function new_alert_msg(params1) {
    this.params = params1 != null ? params1 : {};
    this.create_footer = bind(this.create_footer, this);
    this.rotatating = true;
    this.deg = 40;
    this.in_rotation = false;
    this.background = new_dom_element({
      nodeName: 'div',
      style: {
        position: 'fixed',
        height: '100%',
        width: '100%',
        top: 0,
        left: 0,
        backgroundColor: 'rgba(36, 42, 48, 0.38)',
        zIndex: 100000,
        textAlign: 'center'
      },
      onclick: function(evt) {
        if (evt.target !== this.background) {
          return;
        }
        if (this.params.onclose != null) {
          this.params.onClose();
        }
        this.hide();
        if (typeof evt.stopPropagation === "function") {
          evt.stopPropagation();
        }
        if (typeof evt.preventDefault === "function") {
          evt.preventDefault();
        }
        if (typeof evt.stopImmediatePropagation === "function") {
          evt.stopImmediatePropagation();
        }
        return false;
      }
    });
    if (this.params.parent != null) {
      this.params.parent.appendChild(this.background);
    }
    this.popup = new_dom_element({
      nodeName: 'div',
      style: {
        marginTop: '30px',
        display: 'inline-block',
        width: '80%',
        backgroundColor: '#FFF',
        zIndex: 100001,
        borderRadius: '30px'
      }
    });
    this.background.appendChild(this.popup);
    this.create_content();
    this.create_footer();
  }

  new_alert_msg.prototype.create_header = function() {
    this.header = new_dom_element({
      style: {
        width: '100%',
        backgroundColor: "#1a2229",
        color: '#fff'
      }
    });
    this.popup.appendChild(this.header);
    this.title = new_dom_element({
      nodeName: 'span'
    });
    if (this.params.title != null) {
      this.title.innerHTML = this.params.title;
    }
    this.title_close = new_dom_element({
      nodeName: 'span',
      innerHTML: 'x',
      style: {
        display: 'block',
        float: 'right',
        position: 'relative',
        right: '10px',
        cursor: 'pointer'
      },
      onclick: (function(_this) {
        return function(evt) {
          if (evt.target !== _this.title_close) {
            return;
          }
          if (_this.params.onclose != null) {
            _this.params.onClose();
          }
          _this.hide();
          if (typeof evt.stopPropagation === "function") {
            evt.stopPropagation();
          }
          if (typeof evt.preventDefault === "function") {
            evt.preventDefault();
          }
          if (typeof evt.stopImmediatePropagation === "function") {
            evt.stopImmediatePropagation();
          }
          return false;
        };
      })(this)
    });
    this.header.appendChild(this.title);
    return this.header.appendChild(this.title_close);
  };

  new_alert_msg.prototype.create_content = function() {
    this.content = new_dom_element({
      style: {
        width: '100%',
        color: '#000',
        position: 'relative',
        padding: '15px',
        fontSize: 'xx-large'
      }
    });
    this.popup.appendChild(this.content);
    this.img = new_dom_element({
      nodeName: 'img',
      src: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA4oAAAPUCAYAAADrCcd/AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAAASAAAAEgARslrPgAAgABJREFUeNrs3Xd0FdX6xvF30iGEllClJPQWEJAiiVx6E5UWmnQFRFGwXdv1Ale9gl4UVFSKIlUkgEqX3kKvoRch9JZASCE9+/fHT1lGWso5Z5858/2sxVJRk2eHTM488+6ZYyilBAAA2F56erq6cOGCnD9/XmJiYiQmJkauX78u0dHRd/45JiZGkpOTJTY2VkREUlNTJTExUUREEhMTJTU1VUREChcuLIZhiIeHh/j5+YmISL58+cTHx0f8/f3F399fAgIC7vz9n/9cunRpKV++vBQoUMDQ/fUAAJiHQVEEACD34uPj1eHDh+XkyZNy5swZiYqKuvPr/Pnzkp6erjuiiIgUK1ZMAgMD7/wKCgqSoKAgqVGjhpQrV44SCQDIgqIIAEA2Xbp0Se3Zs0f27NkjR44ckcOHD8uxY8ckMzNTd7Q8KVSokFSqVElq1Kgh9evXl/r160udOnXEz8+PAgkAFkVRBADgHm7cuKG2bdsmW7dulS1btsju3bvl9u3bumM5jGEYUrVqVWnSpImEhoZKkyZNpGrVqhRHALAIiiIAACJy7tw5tX79eomIiJCIiAg5evSo8BqZVbFixeTxxx+X0NBQeeKJJ6RBgwbi7u5OeQQAF0RRBABYUnp6utq+fbssXbpU1qxZI3v37qUY5lDRokWlZcuW0qpVK+nQoYOUKVOG0ggALoKiCACwjHPnzqlly5bJihUrZN26dXeeLoq8MwxD6tatK+3atZMOHTrI448/Lm5ubhRHADApiiIAwKVdvHhRLViwQMLDw2Xr1q1MDR0kICBAunTpIn379pWQkBAxDIPSCAAmQlEEALicmJgYtWzZMgkPD5eVK1c6zVtUWFWZMmWkS5cuEhYWRmkEAJOgKAIAXEJqaqr69ddfZdq0abJ27VrJyMjQHQn3UKFCBRk0aJAMHDhQSpcuTWEEACdFUQQAmNrJkyfVd999J9OnT5dr167pjoNscnNzkxYtWsiQIUOkc+fO4uHhQWkEACdCUQQAmE5KSopasGCBTJs2TTZu3Mh9hyZXpkwZGTRokDz33HNSrlw5CiMAOAGKIgDANG7duqV++OEH+d///icXLlzQHQc25ubmJh06dJD33ntPGjduTGEEAI0oigAAp3fmzBk1YcIE+e6773hLC4sICQmRESNGSJcuXcTd3Z3SCAAORlEEADitbdu2qfHjx8vPP/8smZmZuuNAg2rVqslrr70m/fr1E29vbwojADgIRREA4HR27NihPvzwQ1m6dKnuKHASZcqUkTfeeEOGDh0qPj4+FEYAsDOKIgDAaRw6dEj95z//kQULFvCAGtxTuXLl5L333pNBgwbxpFQAsCOKIgBAuyNHjqjRo0dTEJFtgYGB8s4778hzzz3HPYwAYAcURQCANhcvXlTvvvuuzJ49m3sQkSs1atSQzz77TNq2bUtZBAAboigCABwuNTVVffPNN/L+++9LfHy87jhwAa1atZIJEyZIzZo1KYwAYAMURQCAQy1ZskSNGDFCzpw5ozsKXIynp6cMHDhQPvroIwkICKAwAkAeUBQBAA6xb98+NWLECNm8ebPuKHBxxYoVkw8++EAGDx4sbm5uFEYAyAWKIgDArpKSktS4cePkv//9r6SlpemOAwupV6+eTJ06VerVq0dZBIAcoigCAOxm06ZNasiQIXL8+HHdUWBRnp6e8tprr8mYMWPE29ubwggA2URRBADYXGxsrHrrrbdk6tSpvN0FnEKlSpVkypQp0rx5c8oiAGSDm+4AAADXEh4erqpVqyZTpkyhJMJpnDp1Slq1aiUvvfSSSkhI4BsTAB6CiSIAwCbi4uLUm2++KVOmTNEdBXigwMBAmT17toSEhDBdBID7YKIIAMizHTt2qPr161MSYQpRUVHSrFkzGT16tMrIyOCKOQDcAxNFAECupaenq/Hjx8v777/PE01hSo0bN5bZs2dLxYoVmS4CwF9QFAEAufL777+rPn36yPbt23VHAfKkUKFCMmnSJHn22WcpiwDwB4oiACDHli5dqvr27SuxsbG6owA207dvX5k8ebLky5ePwgjA8rhHEQCQbUopNW7cOPXMM89QEuFyZs2aJaGhoRIVFcVVdACWx0QRAJAtN27cUL1795bffvtNdxTArgICAmTu3LnSunVrJosALIuJIgDgofbv368aNGhASYQlREdHS/v27WX06NFKcUUdgEUx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zz8vwcHBTBn/gqIIwGz4uQXgQZgowqUkJSWpadOmqUaNGqkaNWrIuHHjKIk2dPnyZfniiy+kTp068sQTT6jZs2er1NRUpowi4ubGj1MA5sLPLQAPwk8IuISrV6+q0aNHq3LlysngwYNl586duiO5NKWUbNmyRfr27SvlypWTt99+W126dMnShdHLy0t3BADIEW9vb90RADgxiiJMbffu3apPnz6qXLlyMmbMGImOjtYdyXKuXr0q48aNk4oVK8rzzz+vDh06ZMnCyAkXALPh5xaAB6EowpQOHDigunfvrho2bChz5szhPgsnkJycLN99953Url1bnnrqKbVnzx5LFUYmigDMhp9bAB6EoghT+bMg1q1bV8LDw4X3rXM+SilZunSpNGjQwFKF0d3d3XB3d9cdAwCyjYkigAehKMIUDhw4oJ588kn16KOPUhBN4q+FsUuXLurYsWMu/4fG1XkAZsLPLAAPQlGEU4uOjlYjRoxQ9evXl+XLl+uOg1xQSsnPP/8swcHBMnToUHXt2jWXLYxcnQdgJvzMAvAgFEU4paSkJDVu3DhVsWJF+eKLLyQjI0N3JORRenq6TJkyRSpWrCijR49WycnJLlcYfXx8dEcAgGyjKAJ4EIoinE54eLiqUqWKvP322xIXF6c7DmwsISFBxowZIzVr1pRly5a5VFksUqSI7ggAkG3+/v66IwBwYhRFOI1Lly6pbt26qe7du8uFCxd0x4GdnT59Wjp27ChPPfWUunDhgksUxoCAAN0RACDbKIoAHoSiCO0yMzPVlClTVLVq1WThwoW648DBli5dKrVq1ZKJEyeqzMxMUxdGTroAmAkXtwA8CEURWh06dEg1btxYhg4dKvHx8brjQJNbt27JyJEjpWnTpnL8+HHTlkVOugCYhZubmxQuXFh3DABOjKIILZRSasqUKapRo0aya9cu3XHgJCIiIqRu3boyceJEpUz4HigURQBmUbRoUXFzczN05wDgvCiKcLirV6+qjh07ytChQ+X27du648DJJCUlyciRI6V9+/Zy6dIlU5VFtp4CMAt+XgF4GIoiHGrhwoWqZs2avCciHuq3336TRx99VH799VfTlEVOvACYBTsgADwMRREOkZqaql588UXVrVs3iYmJ0R0HJnH9+nXp1KmTvPrqqyo9Pd3pC2PJkiV1RwCAbClevLjuCACcHEURdnfx4kXVrFkz+eabb3RHgUlNmDBBmjdvLpcvX3bqsli+fHndEQAgW4KCgnRHAODkKIqwq02bNqnHHntMtm3bpjsKTG7Lli1Sp04dWbdundOWxaCgIDEMng0BwPkFBgbqjgDAyVEUYTfjx49XLVu2lCtXruiOAhdx/fp1adeunXzxxRdOWRbz5ctnsJ0LgBkwUQTwMBRF2Fx6eroaNmyYeuONNyQ9PV13HLiYtLQ0GTFihDz//PMqLS3N6QojV+kBmAE/qwA8DEURNpWQkKCeeeYZ+fbbb3VHgYv77rvvpGPHjhIXF+dUZZGr9ADMgKII4GEoirCZS5cuqaZNm/LWF3CYVatWSWhoqJw/f95pyiInXwCcXbFixaRAgQLcUA3ggSiKsIn9+/erBg0ayL59+3RHgcUcPHhQQkJC5ODBg05RFpkoAnB2/JwCkB0UReTZ7t27VcuWLeXSpUu6o8Cizp8/L02bNpXt27drL4s1atTQHQEAHoifUwCyg6KIPNm8ebNq0aKF3LhxQ3cUWFxsbKy0bt1a+9tnBAcH8xYZAJxacHCw7ggATICiiFzbsGGD6tChg8THx+uOAoiISEJCgjz11FOyatUqbWWxUKFCRrly5XR/KQDgvmrXrq07AgAToCgiV5YtW6bat28vCQkJuqMAWdy+fVueeuop+fnnn7WVRU7CADgzfkYByA6KInJs2bJlqnPnzpKcnKw7CnBPqamp0qNHD1m2bJmWsshJGABnVaxYMSlevDj74wE8FEURORIREaF69OghaWlpuqMAD5SWliZhYWGyYcMGh5dF7v8B4KweffRR3REAmARFEdm2c+dO1b59e0lMTNQdBciWpKQk6dixo0RERDi0LFIUATgrfj4ByC6KIrLl4MGDqn379jy4BqaTmJgoHTt2lP379zusLFapUkUKFCige+kAcJe6devqjgDAJCiKeKhTp06p1q1b8xYYMK3Y2Fjp0KGDnD592iFl0cPDw2jUqJHuZQPAXUJDQ3VHAGASFEU80I0bN1THjh3l6tWruqMAeXL58mV58skn5ebNmw4piyEhIbqXDABZlC5dWgIDA3mQDYBsoSjivtLS0lT37t3l+PHjuqMANnHs2DHp1KmTpKam2r0sUhQBOBumiQBygqKI+3r55Zdl7dq1umMANrVp0yYZNmyY3T9P48aNxd3dXfdyAeAOLmAByAmKIu7p448/VpMnT9YdA7CL77//Xj799FO7ThULFixo1KpVS/dSAeAOiiKAnKAo4i6LFy9W//rXv3THAOzq7bfflqVLl9q1LDZp0kT3MgFARER8fX2lTp06umMAMBGKIrI4e/asGjhwoGRmZuqOAthVZmam9OvXz65PQn3iiSd0LxMAROT/t8N7eHjwIBsA2UZRxB3JycmqS5cuvA0GLOPmzZvSpUsXSUpKsktZbN26tbi58WMWgH5t27bVHQGAyXAGgzuGDx8ue/fu1R0DcKgDBw7Iq6++apePHRAQYDz22GO6lwgA0r59e90RAJgMRREiIjJnzhz13Xff6Y4BaDF58mSZMWOGXaaK7dq10708ABZXpkwZqVmzpu4YAEyGogg5fvy4GjJkiO4YgFYvvfSSnDx50uZlkaIIQLd27dqJYRjcnwggRyiKFpeenq769+8vt2/f1h0F0CoxMVF69eolaWlpNi2LDRs2FH9/f93LA2BhXLACkBsURYv76KOPZMeOHbpjAE5hz549Mm7cOJt+THd3d6N169a6lwbAojw8PKRly5a6YwAwIYqihe3du1d99NFHumMATmXMmDGya9cum04VO3TooHtZACyqSZMmUrhwYbadAsgxiqJFJScnq379+klaWpruKIBTSU9Pl/79+9v0LTOeeuop8fb21r00ABYUFhamOwIAk6IoWtSoUaPk8OHDumMATuno0aPyn//8x2Yfr3Dhwmw/BeBwbm5u0qVLF90xAJgURdGCDh06pD7//HPdMQCn9r///U8OHDhgs6li9+7ddS8JgMU0bdpUSpcuzbZTALlCUbSYzMxMNXToULacAg+Rnp4uw4cPF6WUTcpip06dJF++fLqXBcBCevTooTsCABOjKFrMtGnTZOvWrbpjAKawZcsWmT59uk0+lp+fn9G2bVvdSwJgEe7u7mw7BZAnFEULiY6OVu+9957uGICpvPnmm3Lt2jWbTBXZfgrAUVq0aCHFixdn2ymAXKMoWsg///lPiY6O1h0DMJUbN26IrS6wPPXUU5I/f37dSwJgAVyYApBXho1uv4GTi4yMVHXr1pXMzEzdUQDTcXd3l3379klwcHCer84PGDBAzZgxQ/eSALgwX19fuXTpkhQsWJCJIoBcY6JoEW+++SYlEciljIwMeeutt2zysQYPHqx7OQBcXM+ePSmJAPKMiaIF/Pbb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SQQAAPgbtp7iLkFBQcbPP/8s3t7euqMAduHj4yM///wzJREAAOA+KIq4p9DQUGPGjBliGJxHw7UYhiHfffedPP7443xzAwAA3AdFEffVo0cP4/3339cdA7CpDz74QHr37k1JBAAAeADuUcQDKaVU3759Zc6cObqjAHnWs2dPmTt3rhiMygEAAB6IooiHSk5OVh07dpS1a9fqjgLkWtu2bWXx4sU84RQAACAbKIrIltu3b6u2bdvKli1bdEcBcqxx48ayevVqKVCgACURAAAgGyiKyLZbt26pFi1ayN69e3VHAbKtdu3asmHDBilSpAglEQAAIJsoisiR69evq3/84x9y9OhR3VGAh6pcubJs2rRJSpYsSUkEAADIAZ56ihwpVqyY8dtvv0lQUJDuKMADBQUFydq1aymJAAAAuUBRRI6VLVvWiIiIkJo1a+qOAtxT1apVZePGjVK2bFlKIgAAQC6w9RS5du3aNdW6dWuJjIzUHQW4o3r16rJmzRopXbo0JREAACCXmCgi14oXL25s2LBBGjVqpDsKICIi9erVk02bNlESAQAA8oiiiDwpUqSI8dtvv0lISIjuKLC4kJAQWbdunQQEBFASAQAA8oiiiDwrVKiQsWbNGunZs6fuKLCoTp06yapVq6RQoUKURAAAABugKMImfHx8jLlz58qoUaN0R4HFvPLKK7Jw4ULJnz8/JREAAMBGeJgNbG7q1KnqxRdflPT0dN1R4MLc3d3l888/l5dffpmCCAAAYGMURdjFkiVLVK9evSQxMVF3FLggX19fmTt3rjz99NOURAAAADugKMJujh07prp06SJHjx7VHQUupFKlSrJw4UKpXbs2JREAAMBOuEcRdlOtWjVjx44d0rVrV91R4CI6duwoO3fupCQCAADYGUURduXn52eEh4fLhAkTxMPDQ3ccmJRhGPLWW2/Jr7/+KkWKFKEkAgAA2BlbT+Ewa9asUX369JGrV6/qjgITKV68uMyePVtat25NQQQAAHAQJopwmFatWhkHDx6UZ555RncUmESbNm1k3759lEQAAAAHoyjCoYoVK2b88ssvxowZM6RAgQK648BJ+fj4yIQJE2TlypVSunRpSiIAAICDsfUU2pw5c0b17dtXIiIidEeBEwkODpY5c+ZIcHAwBREAAEATJorQJigoyFi/fr18/PHHki9fPt1xoJmPj498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mTNnSnJysu44llS5cmV59dVXZeDAgeLj40NhBAAAADSzbFE8e/as+u9//yvff/+9pKen644DESlevLi89tprMmLECAojAAAAoJHliuL58+fV//73P5k8ebKkpKTojoN7KFeunLz33nsyaNAg8fDwoDACAAAADmaZohgbG6s++OADmTRpEgXRJCpXriyffPKJdOrUibIIAAAAOJDLF8XMzEw1e/Zs+ec//ylXr17VHQe50Lx5c5kwYYLUrl2bwggAAAA4gJvuAPa0fv16Va9ePenfvz8l0cTWr18v9erVkxdffFFFR0e79pUNAAAAwAm45ETx5s2b6u2335apU6eKK67PyooUKSJjx46VwYMHi2EYTBgBAAAAO3C5ohgeHq5eeukluX79uu4osKN//OMfMmXKFKlSpQplEQAAALAxl9l6evbsWdWhQwfVvXt3SqIFbNy4UerWrSufffaZysjIcK2rHQAAAIBmLjFRDA8PV0OHDpWbN2/qjgINGjduLLNnz5aKFSsyXQQAAABswNQTxbi4ONW3b1/VvXt3SqKFbd++XerVqyezZs0y/1UPAAAAwAmYdqK4fft21adPH/n99991R4ETCQsLk8mTJ0uRIkWYLgIAAAC5ZLqJolJKffzxxyo0NJSSiLuEh4dLgwYN5MCBA+a8AgIAAAA4AVNNFOPj49XAgQNl4cKFuqPAyfn4+MikSZNk0KBBTBYBAACAHDJNUTx+/Ljq0qWLHDlyRHcUmMiQIUPkyy+/FC8vLwojAAAAkE2mKIq//vqr6tu3r8THx+uOAhMKDQ2Vn3/+WQICAiiLAAAAQDY4/T2KEydOVF27dqUkIte2bNkijRo1kmPHjjn/VREAAADACThtUczIyFAjRoxQI0eOlIyMDN1xYHKnT5+WkJAQ2bhxI2URAAAAeAin3HqamJioevfuLYsXL9YdBS7G29tbpk+fLr169WIbKgAAAHAfTjdRvHXrlmrTpg0lEXaRkpIizz77rEyYMMH5rpAAAAAATsKpiuLNmzdVmzZtZOvWrbqjwIUppeTVV1+VMWPGUBYBAACAe3CaradXr15VrVu3loMHD+qOAgt56623ZOzYsWxDBQAAAP7CKYri+fPnVcuWLeXkyZO6o8CCXn31Vfnss88oiwAAAMAftBfFa9euqWbNmsnRo0d1fy1gYSNHjpTPP/+csggAAACI5nsUY2NjVbt27SiJ0G7ChAnywQcf6B+vAwAAAE5A20QxLi5OtWzZUnbv3q37awDc8cknn8ibb77JZBEAAACWpqUo3r59W7Vp00YiIiJ0rx/IwjAMmTx5sgwePJiyCAAAAMtyeFHMzMxUYWFhsmjRIt1rB+7J3d1dFi1aJE8//TRlEQAAAJbk8HsU33jjDUoinFpGRoY8++yzsm/fPu5ZBAAAgCU5dKI4ZcoUNXToUN1rBrKlVKlSsn37dilXrhyTRQAAAFiKw4ri0qVLVadOnSQjI0P3moFsq127tmzZskX8/PwoiwAAALAMhxTFEydOqIYNG8qtW7d0rxfIsWeeeUZ+/vlnMQyDsggAAABLsPs9igkJCapLly6URJjWr7/+Kp988onuGAAAAIDD2HWiqJRSPXv2lPnz5+teJ5Anbm5usnz5cmnbti1TRQAAALg8u04U//e//1ES4RIyMzOld+/ecubMGZ6ECgAAAJdnt4ni7t27VZMmTSQtLU33GgGbadKkiWzcuFE8PDyYLAIAAMBl2WWimJiYqJ599llKIlzO1q1b5aOPPtIdAwAAALAru0wUBw4cqH744QfdawPswsPDQzZt2iSPP/44U0UAAAC4JJsXxUWLFqmuXbvqXhdgVxUqVJB9+/ZJwYIFKYsAAABwOTbdenr58mU1ePBg3WsC7O706dPy6quv6o4BAAAA2IVNi+Lw4cPlxo0butcEOMT3338vq1ev5imoAAAAcDk223q6ZMkS9fTTT+teD+BQgYGBcujQIfH19WULKgAAAFyGTSaKt27dUsOGDdO9FsDhoqKiZMyYMbpjAAAAADZlk6L45ptvysWLF3WvBdDis88+kz179rAFFQAAAC4jz1tPt2/frpo0aSL2eJsNwCzq1asnu3btEjc3N7agAgAAwPTyNFFUSqmRI0dSEmF5e/fulVmzZumOAQAAANhEniaKs2bNUv369dO9BsAplChRQk6cOMF7KwIAAMD0cj1RvH37tvrXv/6lOz/gNK5evSrjxo3THQMAAADIs1wXxbFjx8q5c+d05wecymeffSZRUVHsxQYAAICp5WrraXR0tKpQoYLEx8frzg84nQEDBsj06dPZfgoAAADTytVE8eOPP6YkAvcxa9YsOXbsGFNFAAAAmFaOJ4qXL19WlSpVktu3b+vODjit3r17y5w5c5gqAgAAwJRyPFH873//S0kEHmLevHkSGRnJVBEAAACmlKOJ4vnz51XlypUlJSVFd27A6XXr1k3Cw8OZKgIAAMB0cjRRnDhxIiURyKZFixZxryIAAABMKdtFMT4+Xk2bNk13XsA0MjMz5csvv9QdAwAAAMixbBfFyZMny61bt3TnBUzlhx9+kOjoaKaKAAAAMJVsFcX09HTFZATIudu3b8s333yjOwYAAACQI9kqiuHh4XLu3DndWQFTmjRpkqSkpDBVBAAAgGlkqyh+++23unMCpnX16lX55ZdfdMcAAAAAsu2hRfHEiRNq8+bNunMCpjZ16lTdEQAAAIBse2hRnDp1quTkvRYB3G3dunVy6tQpDiQAAACYwgOLYmpqqpo5c6bujIDpKaVk+vTpumMAAAAA2fLAovjrr7/KtWvXdGcEXML06dMlPT2dqSIAAACc3gOL4uzZs3XnA1zG5cuXZf369bpjAAAAAA/lcb9/ERcXp1atWqU7H+BS5s+fL61bt9YdAwAAAA5w8eJFtXPnTjlx4oScOHFCjh8/LtevX5fExERJTEyU2NhYKVCggBQoUEB8fX2lWLFiEhQUJNWqVZOqVatKnTp1pFq1aoaO7Mb9HlQzc+ZM1b9/f61fWMDVFClSRK5cuSJeXl5aDngAAADYT1JSklq2bJmsXbtW1q1bJydOnMjzxyxVqpS0aNFCWrRoIc8884z4+/s75DzyvkWxY8eOatmyZY7IAFjK8uXLpX379hRFAAAAF6CUUps2bZKZM2fKggULJC4uzm6fy8vLSzp06CD9+vWTJ5980q7Dh3sWxdjYWFWiRAlJTU212yIBqxowYIBMnz6doggAAGBimZmZatmyZTJ69GjZu3evwz9/8eLFZdiwYfLaa69JwYIFbX5uec+H2SxbtoySCNjJkiVLJCMjg6efAgAAmJBSSs2cOVNVqVJFnn76aS0lUUTk2rVrMmbMGKlYsaKMHTtWpaSk2PT88p5FceXKlVoWC1hBTEyM7Nq1S3cMAAAA5NDx48dV69atpX///vL777/rjiMiItHR0fLOO+9IrVq1ZOXKlTYri3cVxczMTJ52CtgZF2MAAADMIy0tTb3zzjsqODhY1q5dqzvOPZ06dUrat28vvXv3VrGxsXkujHcVxT179si1a9d0rxNwaStWrNAdAQAAANlw/vx51bx5cxk7dqykpaXpjvNQP/74o9SpU0e2bduWp7J4V1HkBBawv927d8u1a9e4TxEAAMCJrVixQj366KMSERGhO0qOnDt3Tpo1ayZfffVVrs837yqKq1ev1r0uwOVlZmY67bYFAAAAiMyePVs988wzcuPGDd1RciU1NVVefvllGTFihMrMzMxxYcxSFFNSUtTu3bt1rwmwhC1btuiOAAAAgHuYOHGi6t+/vym2mj7MF198IQMGDJC0tLQclcUsRXH37t2SnJysey2AJZhtCwMAAIAVjBs3To0cOVIyMzN1R7GZWbNmSf/+/SUnk8UsRZETV8BxDh48KLdu3eI+RQAAACcxa9Ys9c477+iOYRc//vijvPzyy9n+7ymKgCaZmZmyY8cO3TEAAAAgIkuWLFGDBg0SpVz3Ov7XX38tY8eOzdYCsxTFbdu26c4OWAoXZwAAAPT7/fffVd++fSU9PV13FLt77733ZNWqVQ8ti3eK4tmzZ9X169d15wYsZc+ePbojAAAAWFpaWprq06eP3Lp1S3cUh8jMzJS+ffvKpUuXHlgW7xTFyMhI3ZkBy+G4AwAA0OvNN9+U7du3647hUNeuXZM+ffqIesA+W4oioNH58+fl5s2brrsRHgAAwInt3r1bffXVV7pjaLF+/XqZPn36ff/9naJ48OBB3VkBS+LYAwAAcLzMzEz10ksvSUZGhu4o2vzzn/+U6Ojoew4tmCgCmlEUAQAAHO/bb7+VnTt36o6hVUxMjPzrX/+6579zExFJTU1VJ0+e1J0TsKRDhw7pjgAAAGApKSkp6qOPPtIdwyl8//33cubMmbumim4iIufOnbPEo2ABZ3TmzBndEQAAACzl+++/l0uXLumO4RTS0tLkk08+uev33UREoqKidOcDLIuiCAAA4DgZGRnqs88+0x3DqUyfPl0uXryYZaroJsKJKqDT2bNnJTMzkyefAgAAOMDixYvl1KlTumM4lZSUFJk6dWqW33MT+f8TVQB6pKSkyJUrV3THAAAAsIRZs2bpjuCUZsyYkeV9Fdl6CjgBpvoAAAD2d+PGDbV8+XLdMZxSVFSURERE3PlnNxGRixcv6s4FWNqFCxd0RwAAAHB5CxYskJSUFN0xnNbcuXPv/L2biMj169d1ZwIsLSYmRncEAAAAl7d69WrdEZzamjVr7vy9mwgnqYBu0dHRuiMAAAC4NKWU2rBhg+4YTu3kyZNy9uxZJfJHUbxx44buTIClcbEGAADAvg4cOMDF+WxYv369iIi4xcXFqdTUVN15AEujKAIAANjXzp07dUcwhR07doiIiBsnqIB+HIcAAAD2dezYMd0RTOH48eMiIuKWmJioOwtgeRyHAAAA9vVnAcKD3SmKPB4W0I/jEAAAwL5OnDihO4IpXL58WeLj45Ub9ycC+nEcAgAA2Ne1a9d0RzAFpZRcv35dKIqAE2CiCAAAYD9KKcWtPtkXHx/P1lPAGXAcAgAA2M/t27clIyNDdwzTiI+PF7e0tDTdOQDLY7IPAABgP0wTcyY+Pl7c3N3ddecALM/Dw0N3BAAAAJfl5eWlO4KpeHt7ixtfNEA/jkMAAAD7KVCggO4IplKwYEGKIuAMvL29dUcAAABwWR4eHka+fPl0xzANPz8/ceMEFdCP4xAAAMC+ChcurDuCaRQqVIiJIuAMOA4BAADsq0KFCrojmIKvr6+UKFFC3Hx8fHRnASyP4xAAAMC+qlatqjuCKVStWlUMwzDcihYtqjsLYHn+/v66IwAAALg0imL2/Pl1citatKi4ubnpzgNYGkURAADAvurUqaM7ginUrl1bRETc3N3djUKFCunOA1gaRREAAMC+QkJCxNPTU3cMp9e8eXMREXETEQkICNCdB7A0iiIAAIB9FShQwGjYsKHuGE7Nz89P6tevLyJ/FEVOUgG9uFgDAABgfy1atNAdwak1a9ZMPDw8DJE/imKJEiV0ZwIsrVixYrojAAAAuLzOnTvrjuDUunTpcufv3UREypcvrzsTYGlBQUG6IwAAALi8unXrGn8+rAVZ5c+fX7p27Xrnn91ERAIDA3XnAizLMAwu1gAAADhInz59dEdwSp07dxY/Pz/jz3+mKAKalSpVSnx8fIy8fyQAAAA8TN++fcXb21t3DKfz3HPPZflnNxG2vQE6cfwBAAA4TsmSJY2BAwfqjuFUGjVqJM2bN88yuGCiCGjG8QcAAOBY77zzDu+p+Bfvv//+Xb/nJiJSuHBho2TJkrrzAZZUrVo13REAAAAspVy5csazzz6rO4ZTqF+/vnTo0OGu33f78294+g+gB8ceAACA43388cdSuHBh3TG0MgxDPvvsMzEM467nZVAUAc049gAAAByvZMmSxujRo3XH0GrgwIHStGnTez5U8U5RDA4O1p0TsBw/Pz/eGgMAAECT4cOHS926dXXH0MLf31/Gjh1733/PRBHQKDg4+J6jfgAAANifu7u78dNPP4mfn5/uKA5lGIZMmzZNihUrdt/z0DtFsXr16uLl5aU7M2ApXKABAADQq3LlysaUKVN0x3Co119/XTp16vTAYcWdoujt7W3Uq1dPd2bAUkJCQnRHAAAAsLyePXsazz//vO4YDhESEiL//e9/H/rfuf39fwLgOBxzAAAAzuHrr7++59tEuJLKlSvLokWLxNPT86G3PlEUAU1KliwpQUFB3J8IAADgBDw9PY0FCxa4bCcqXbq0rF69WooXL56t80+KIqDJE088oTsCAAAA/iJfvnzGr7/+KvXr19cdxaZKly4tq1atkvLly2d7SJGlKBYvXtyoVKmS7nUAlsCFGQAAAOfj7+9vbNy4Udq1a6c7ik1UrFhRNm7cKDVr1szRTja3v/9GixYtdK8FsITmzZvrjgAAAIB78PX1NX799Vfp1auX7ih50rhxY9m+fbtUqlQpx7c73VUUXaU5A86sVKlSEhwcrDsGAAAA7sPLy8uYO3euMXnyZFO+jeCQIUNkw4YNEhAQkKtnYtxVFFu1amXKLwRgJh06dBDDMHiQDQAAgJMbMmSIsWXLFgkKCtIdJVsKFy4sCxculMmTJxve3t65Pt+8qyj6+fkZTZo00b0+wKUxuQcAADCPBg0aGIcOHZJRo0Y59VCtY8eOEhkZKV26dMnzQMLtXr/JSSxgPx4eHtKqVSvdMQAAAJAD+fPnN0aPHm3s3btXmjVrpjtOFtWrV5e1a9fKkiVLjLJly9pk19o9i2LHjh11rxVwWSEhIVK4cGG2nQIAAJhQzZo1jfXr1xubN2/W3ptq1aolM2bMkMjISGnRooVNzy/vWRRr1qxp1KxZU+uiAVfVo0cP3REAAACQR6GhocaSJUuMrVu3Sp8+fcTX19chn9fDw0OefPJJ+eWXXyQyMlL69etneHh42HwIYSil7vkvxowZo0aPHu2QxQJW4e7uLhcvXpQSJUowUQQAAHAhCQkJatGiRTJv3jzZtGmTJCYm2uxje3h4SKNGjaRbt27Sq1cvh5xL3rcoHj9+XFWrVs3enx+wlJYtW8qaNWsoiQAAAC4sNTVV7dixQ9atWye7du2S48ePS1RUlKSnp2fr/y9XrpxUqVJF6tSpIy1atJCmTZtKgQIFHHoOed+iKCJSp04dFRkZ6cg8gEubMmWKDB48mKIIAABgMampqer06dNy/fp1SUhIkISEBLl586b4+flJgQIFxM/PT/z9/aVChQri6+ur/XzxgUXx448/Vu+++67ujIBL8PT0lEuXLuX6TU8BAAAAR3F70L8cMGCAeHh46M4IuISnn36akggAAABTeGBRLFWqlMF7KgK28fzzz+uOAAAAAGSL28P+g8GDB+vOCJhe2bJlpXXr1rpjAAAAANny0KLYoUMHeeSRR3TnBEzt+eefF3d3d7adAgAAwBQeWhQ9PDyMgQMH6s4JmJa7u7twDAEAAMBMHloURUSGDx8uPj4+urMCptStWzcpW7Ys00QAAACYRraKYokSJYyePXvqzgqY0quvvqo7AgAAAJAjD3wfxb86dOiQql27tmT3vwcg0rRpU9m4cSPTRAAAAJhKtiaKIiK1atUy2rRpozsvYCqvv/667ggAAABAjmV7oigismbNGsUj/oHsqVq1qhw5ckTc3NyYKAIAAMBUsj1RFBFp1aqV8cQTT+jODJjC+++/T0kEAACAKeVooigisnbtWtWqVSvduQGnVqNGDYmMjOS9EwEAAGBKOZooioi0bNnSaN68ue7cgFMbPXo0JREAAACmleOJoohIRESECg0N1Z0dcErBwcGyf/9+tp0CAADAtHI8URQRCQkJMdq2bas7O+CUPvzwQ0oiAAAATC1XE0URkSNHjqhHH31U0tLSdK8BcBotWrSQtWvXUhIBAABgarmaKIqI1KhRwxgyZIju/IDTcHd3l88//1x3DAAAACDPcj1RFBG5efOmqly5ssTExOheB6Ddiy++KJMmTWKaCAAAANPL9URRRKRIkSLGv//9b91rALQrUqSIjBkzRncMAAAAwCbyVBRFRIYNGybBwcG61wFo9Z///EcCAgKYJgIAAMAl5Gnr6Z927typmjRpIhkZGbrXAzhcw4YNZevWrbxvIgAAAFxGnieKIiINGzY0hg8frnstgMN5eHjI5MmTKYkAAABwKTYpiiIi//3vf6VChQq61wM41LvvviuPPvooJREAAAAuxSZbT/+0YsUK1aFDB91rAhyiWrVqsn//fvH29qYoAgAAwKXYbKIoItK+fXvj+eef170mwO48PDxk+vTplEQAAAC4JJsWRRGRCRMmSNWqVXWvC7CrMWPGSOPGjSmJAAAAcEk23Xr6pz179qgmTZpIamqq7vUBNhca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izz++ONMGwEAAHAXiiIgIklJSWrNmjUSHh4uixYtksTERN2RHKJMmTLSpUsXCQsLk5CQEEojAAAARISiCIvbs2ePmjJlisyZM8cy5fB+KleuLL1795bnnntOypYtS2EEAACwMIoiLOfWrVtq+vTpMnXqVDly5IjuOE7H09NTnn76aRk6dKi0atWKKSMAAIAFURRhGVFRUerbb7+VyZMnu9x9h/YSHBwsw4cPl379+vG2GwAAABZCUYTLO3DggPr4449l4cKFpntiqbMoXbq0jBgxQl588UUpUKAAhREAAMDFURThso4ePao+/vhjmTt3rt3e+N5q/P395c0335SXX35Z8ufPT2EEAABwURRFuJzTp0+rUaNGydy5cyUzM1N3HJdUqlQpeffdd2Xo0KHi6elJYQQAAHAxFEW4jMTERPXpp5/KuHHjJDk5WXccS6hSpYp8+OGHEhYWRlkEAABwIRRFmF5mZqaaMWOGvPfee3L58mXdcSypffv28tlnn0m1atUojAAAAC6AoghTO3XqlBoyZIisX79edxTL8/T0lNdee03GjBkj3t7eFEYAAAAToyjClNLT09X48eNl1KhRkpKSojsO/qJSpUoyZcoUad68OWURAADApCiKMJ0DBw6ofv36SWRkpO4ouA83NzcZPny4jB07VvLly0dhBAAAMBmKIkxDKaW++OILeeutt5gimkT16tVlzpw5UrduXcoiAACAibjpDgBkx9WrV1XHjh1l5MiRlEQTOXr0qDz++OMybtw4lZmZyVUpAAAAk2CiCKe3adMm1b17d7l69aruKMiDDh06yOzZs6VIkSJMFwEAAJwcE0U4LaWUmjhxomrVqhUl0QUsX75cGjZsKAcPHuTqFAAAgJNjoginlJCQoAYOHCgLFizQHQU25uvrK9OmTZOePXsyWQQAAHBSTBThdC5fvqyaNWtGSXRRiYmJ0rt3bxk9erRSXKkCAABwSkwU4VQOHTqknnzySTl37pzuKHCAfv36ydSpU8XLy4vpIgAAgBOhKMJprF69WnXr1k3i4uJ0R4EDtWjRQhYtWiSFChWiLAIAADgJiiKcwpIlS1T37t0lOTlZdxRoULduXfntt9+kWLFilEUAAAAnwD2K0G7evHmqa9eulEQL27dvnzRt2lQuXrzIlSsAAAAnQFGEVtOmTVPPPvuspKWl6Y4CzY4dOybNmjWTs2fPUhYBAAA0Y+sptJkxY4YaNGiQZGZm6o4CJ1KuXDnZvHmzlCtXjm2oAAAAmlAUocXChQtVz549JT09XXcUOKEqVarIxo0bpWTJkpRFAAAADSiKcLjFixerbt26sd0UD1S7dm1Zv369FC1alLIIAADgYBRFONSmTZtUmzZtJCUlRXcUmEBISIisWbNGfHx8KIsAAAAOxMNs4DC///676tatGyUR2RYRESH9+vWTzMxMrmgBAAA4EEURDhEdHa3at28v169f1x0FJhMeHi7vvvuu7hgAAACWwtZT2F1ycrJq3ry5bN++XXcUmNiUKVNk8ODBbEEFAABwACaKsLuXX36Zkog8e+mll2TLli1c2QIAAHAAJoqwqylTpqihQ4fqjgEXUapUKdm9e7eULl2aySIAAIAdURRhNzt37lRNmzbl4TWwqSZNmsiGDRvE09OTsggAAGAnbD2FXcTGxqru3btTEmFzW7dulVGjRumOAQAA4NKYKMIuevfurX788UfdMeCi3NzcZM2aNdK8eXOmigAAAHZAUYTNzZo1S/Xr1093DLi4MmXKyIEDB6Ro0aKURQCAy7t06ZI6fvy4XLlyReLj4yUuLk6SkpIkMTFRYmNjxcfHR3x9faVgwYJSsGBBKVCggBQsWFAqVqwolStXFm9vb14vkSMURdhUVFSUevTRR+XWrVu6o8ACevToIfPmzeOFDwDgMlJSUtT27dtl8+bNcuTIETlx4oScOHFC4uPjc/0x3d3dpXz58lK1alWpWrWqPProo9K8eXMpV64cr6G4L4oibKpNmzZq9erVumPAQhYuXChdunThhQ4AYEoZGRlq+/btsn79etmwYYNs3bpVkpKSHPK5K1asKC1atJDmzZtLixYtpESJErye4g6KImxm+vTpatCgQbpjwGJKliwpR44ckSJFivDiBgAwjSNHjqj58+fLDz/8IGfPntUdR9zc3OTxxx+Xfv36Sa9evcTPz4/XVYujKMImrly5omrWrCk3btzQHQUWNGTIEJk8eTIvaAAAp3b9+nU1a9YsmTlzphw4cEB3nPvy9fWVLl26SL9+/aRly5ZiGAavsRZEUYRN9OjRQ82fP193DFiUYRiyfv16+cc//sELGQDA6Vy9elV9/vnn8tVXX0liYqLuODkSHBwsb7zxhjz77LPi7u7O66yFUBSRZ+vXr1ctWrTQHQMWV7NmTdm/f794eHjwIgYAcApRUVHq888/lylTpkhycrLuOHlSoUIFeeWVV+SFF17gCaoWQVFEnmRkZKj69es79fYJWMc333wjL7zwAi9eAACtYmNj1XvvvSdTpkyR9PR03XFsKigoSD777DPp1KkTr7cujqKIPJk8ebJ64YUXdMcARESkaNGicvLkSd5bEQCgTXh4uHr55Zfl6tWruqPYVcuWLWXSpElStWpVXnNdlJvuADCvuLg49e9//1t3DOCOGzduyEcffaQ7BgDAgk6cOKFat26tunfv7vIlUURk7dq1UrduXRk9erRKTk5m8uSCKIrItQkTJsi1a9d0xwCy+Prrr+XChQu8YAEAHEIppSZMmKCCg4NlzZo1uuM4VFJSkowZM0YaNGggR48e5bXXxVAUkSuxsbFqwoQJumMAd0lOTpaPP/5YdwwAgAXExcWpHj16yKuvviqpqam642hz6NAhqV+/vkyZMoWy6EIoisiVTz/9VG7evKk7BnBPU6dOlTNnzvBiBQCwm927d6u6detKeHi47ihOISkpSYYOHSr9+vVTiYmJvAa7AB5mgxyLjo5WFSpUkPj4eN1RgPt67rnnZNq0adxgDwCwue+//1698MILkpaWpjuKU6pVq5YsX75cypYty+uwiTFRRI5NmjSJkginN3PmTO5VBADY3MSJE9Xzzz9PSXyAQ4cOSaNGjSQyMpLXYROjKCJHUlJS1Lfffqs7BvBQaWlpMmnSJN0xAAAuQiml/vnPf6qRI0cKO/Ie7vLly9KsWTPZsmULXyyToigiR2bOnClXrlzRHQPIlm+//Vbi4+N5gQIA5ElaWprq27evfPrpp7qjmMrNmzelbdu2smzZMl6LTYiiiGxTSqnPP/9cdwwg22JjY+X777/XHQMAYGJKKTV48GCZM2eO7iimdPv2bencubOsXLmSsmgyFEVk2/r16+Xo0aO6YwA58vXXX4tijxAAIJdef/11mTFjhu4YppaWliZdu3aVbdu28XpsIhRFZNvUqVN1RwBy7MSJE7J582bdMQAAJvTRRx+xm8pGbt++LU8//bQcO3aMsmgSFEVkS0xMjPrll190xwByZdq0abojAABMZtq0aer999/XHcOlREdHS/v27eXSpUuURROgKCJbZsyYIcnJybpjALmyYMECuXnzJi9KAIBs2blzp3rppZd4uqkd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QxEAYDr+/v7avn37JCEhQXUK5P/+TmJubq4MGDCAkQgALoKhCAAwJZvNpmVmZsrMmTNVp7i1zp07y6FDh+Sxxx5jJAKAC2EoAgBMy2KxaG+++aa2evVq8fHxUZ3jdhISEmT//v0SEhLCSAQAF8NQBACY3tixY7X8/Hzp0KGD6hS34OnpKampqbJq1SrNx8eHkQgALoihCABwC+3bt9cOHjwoSUlJqlNMLTQ0VHJzcyUlJYWBCAAujJ/HAAC4nU8//VSfMmWK/Pjjj6pTTGXUqFGyZMkS8fPzYyQCgIvjiiIAwO2MHDlSKywslKefflp1iik0b95cNm3aJGvXrtUYiQBgDgxFAIBbCgkJ0bZt26Zt2bJFmjVrpjrHJWmaJuPHj5fjx4/LkCFDGIgAYCIMRQCAWxs8eLD25ZdfSnJysnh6eqrOcRkxMTFy4MABycjI0Bo3bsxIBACT4TOKAAD8W3FxsT5jxgzZs2eP6hTDatasmSxYsEDGjx8vmqYxEAHApBiKAAD8zBdffKG//vrrsm/fPtUphuHv7y+vvvqqTJ06VerXr89ABACTYygCAHAHO3fu1OfPny95eXmqU5Rp0qSJJCcnS3Jysvj6+jIQAcBNMBQBAPgFR48e1RcuXCirV6+W27dvq85xitatW8vUqVMlKSlJ6tWrx0AEADfDUAQA4B6VlJTo6enpsmzZMrlw4YLqHLuzWq0yZMgQeeGFF6Rv375isVgYiADgphiKAADcp9raWn3Hjh2ycuVK2bZtm9y8eVN10gPTNE26du0qY8aMkcTERAkMDGQcAgAYigAAPIyKigp927Ztsn79etm7d69cuXJFddIv8vDwkJiYGBkyZIiMHj1aQkNDGYcAgP/CUAQAwE5qa2v1Q4cOya5duyQ3N1eOHDkit27dUp0lIiLt2rWT2NhY6devn8TFxUmjRo0YhwCAO2IoAgDgINXV1Xp+fr4cOHBACgsL5cSJE3Lq1Cmprq526L/bokULiYyMlMjISImJiZEePXpIUFAQwxAAcM8YigAAOFFNTY3+7bffypkzZ6SkpETOnj0rly5dkrKyMiktLZXS0lK5du2aiIhUVFRIVVWVaJomfn5+IiLi7e0t/v7+P/01bdpUWrRoIaGhoRIWFiZt2rThaiEA4KH9H6FjyjTBnrPZAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE3LTA2LTEyVDAzOjM0OjIzKzA4OjAwGcAbBgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNi0wNC0xNlQxNTozMTo1MCswODowMD/ea2cAAABUdEVYdHN2ZzpiYXNlLXVyaQBmaWxlOi8vL2hvbWUvZGIvc3ZnX2luZm8vc3ZnLzNhL2IzLzNhYjMyZTdmNjRjOGY5ZWUyNTM5MTRkNjI1MzVhZjcwLnN2Z+BlZ8EAAAAASUVORK5CYII=',
      style: {
        height: '35px',
        marginRight: '20px'
      }
    });
    this._loop_spinner_();
    this.content.appendChild(this.img);
    this.msg = new_dom_element({
      nodeName: 'span'
    });
    return this.content.appendChild(this.msg);
  };

  new_alert_msg.prototype._loop_spinner_ = function() {
    if (this.in_rotation === true) {
      return;
    }
    this.in_rotation = true;
    this.deg = (this.deg + 360) + 1;
    this.img.style.WebkitTransitionDuration = '2.2s';
    this.img.style.webkitTransform = "rotate(" + this.deg + "deg)";
    this.img.style.transitionTimingFunction = 'linear';
    if (this.rotatating === true) {
      return setTimeout(function() {
        this.in_rotation = false;
        return this._loop_spinner_();
      }, 2000);
    } else {
      return this.in_rotation = false;
    }
  };

  new_alert_msg.prototype.create_footer = function() {
    var b, btn, d, len, q, ref, results;
    this.footer = new_dom_element({
      style: {
        width: '100%',
        color: '#000',
        position: 'relative',
        padding: '15px',
        height: '100px'
      }
    });
    this.popup.appendChild(this.footer);
    ref = this.params.btn;
    results = [];
    for (q = 0, len = ref.length; q < len; q++) {
      btn = ref[q];
      d = new_dom_element({
        style: {
          width: (100 / this.params.btn.length) + "%",
          paddingRight: '5px',
          paddingLeft: '5px',
          float: 'left'
        }
      });
      b = new_dom_element({
        nodeName: 'button',
        innerHTML: btn.txt,
        onclick: btn.click,
        style: {
          display: "inline-block",
          padding: "6px 12px",
          marginBottom: "0",
          fontSize: "x-large",
          fontWeight: "400",
          height: '70px',
          lineHeight: "1.42857143",
          textAlign: "center",
          whiteSpace: "nowrap",
          verticalAlign: "middle",
          touchAction: "manipulation",
          cursor: "pointer",
          userSelect: "none",
          border: "1px solid transparent",
          borderRadius: "4px",
          width: "100%",
          backgroundColor: btn.backgroundColor,
          color: "#fff"
        }
      });
      this.footer.appendChild(d);
      results.push(d.appendChild(b));
    }
    return results;
  };

  new_alert_msg.prototype.hide_btn = function() {
    this.footer.style.display = 'none';
    return this.img.style.display = 'inline';
  };

  new_alert_msg.prototype.show_btn = function() {
    this.footer.style.display = 'block';
    return this.img.style.display = 'none';
  };

  new_alert_msg.prototype.hide = function() {
    this.background.style.display = 'none';
    return this.rotatating = false;
  };

  new_alert_msg.prototype.show = function() {
    this.background.style.display = 'block';
    this.rotatating = true;
    return this._loop_spinner_();
  };

  new_alert_msg.prototype.setMsg = function(msg) {
    return this.msg.innerHTML = msg;
  };

  return new_alert_msg;

})();

_index_current_popup = 10000;

spinal_new_popup = function(title, params) {
  var _drag_end_func, _drag_evt_func, b, clientX, clientY, close_element, extention, height, old_x, old_y, repos, res, t, top_x, top_y, w, width;
  if (params == null) {
    params = {};
  }
  if (params.popup_closer == null) {
    b = new_dom_element({
      parentNode: document.body,
      id: "popup_closer",
      onmousedown: function() {
        if (typeof params.onclose === "function") {
          params.onclose();
        }
        document.body.removeChild(b);
        return document.body.removeChild(w);
      },
      ondrop: function(evt) {
        if (!evt) {
          evt = window.event;
        }
        evt.cancelBubble = true;
        if (typeof evt.stopPropagation === "function") {
          evt.stopPropagation();
        }
        if (typeof evt.preventDefault === "function") {
          evt.preventDefault();
        }
        if (typeof evt.stopImmediatePropagation === "function") {
          evt.stopImmediatePropagation();
        }
        return false;
      },
      style: {
        position: "fixed",
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
        background: params.fixed_opacity || "#000",
        opacity: params.fixed_opacity || 0,
        zIndex: _index_current_popup
      }
    });
  }
  if ((params.event != null) && params.event.clientX) {
    clientX = params.event.clientX;
    clientY = params.event.clientY;
  } else {
    clientX = window.innerWidth / 2 - 10;
    clientY = window.innerHeight / 2 - 10;
  }
  top_x = params.top_x || -1000;
  top_y = params.top_y || -1000;
  old_x = 0;
  old_y = 0;
  w = void 0;
  if (params.width != null) {
    width = params.width;
  }
  if (params.height != null) {
    height = params.height;
  }
  repos = function() {
    top_x = clientX - w.clientWidth / 2;
    top_y = clientY - w.clientHeight / 2;
    if ((top_x + w.clientWidth) > window.innerWidth) {
      top_x = window.innerWidth - w.clientWidth - 50;
    }
    if ((top_y + w.clientHeight) > window.innerHeight) {
      top_y = window.innerHeight - w.clientHeight + 50;
    }
    if (top_x < 50) {
      top_x = 50;
    }
    if (top_y < 50) {
      top_y = 50;
    }
    w.style.left = top_x;
    return w.style.top = top_y;
  };
  _drag_evt_func = function(evt) {
    top_x += evt.clientX - old_x;
    top_y += evt.clientY - old_y;
    w.style.left = top_x;
    w.style.top = top_y;
    old_x = evt.clientX;
    old_y = evt.clientY;
    return typeof evt.preventDefault === "function" ? evt.preventDefault() : void 0;
  };
  _drag_end_func = function(evt) {
    if (typeof document.detachEvent === "function") {
      document.detachEvent("onmousemove", _drag_evt_func);
    }
    if (typeof document.detachEvent === "function") {
      document.detachEvent("onmouseup", _drag_end_func);
    }
    if (typeof document.removeEventListener === "function") {
      document.removeEventListener("mousemove", _drag_evt_func, true);
    }
    return typeof document.removeEventListener === "function" ? document.removeEventListener("mouseup", _drag_end_func, true) : void 0;
  };
  extention = "px";
  if (!params.top_x) {
    setTimeout(repos, 1);
    extention = "%";
  }
  w = new_dom_element({
    parentNode: document.body,
    className: "Popup",
    style: {
      position: "absolute",
      left: top_x,
      top: top_y,
      width: width + extention,
      height: height + extention,
      zIndex: _index_current_popup + 1,
      border: 'thin solid black',
      background: '#e5e5e5',
      resize: 'both',
      overflow: 'auto',
      paddingBottom: '8px'
    }
  });
  _index_current_popup += 2;
  close_element = new_dom_element({
    parentNode: w,
    className: "PopupClose",
    txt: "Close",
    style: {
      float: 'right',
      marginRight: '4px',
      marginTop: '4px',
      cursor: 'pointer'
    },
    onmousedown: function(evt) {
      if (typeof params.onclose === "function") {
        params.onclose();
      }
      if (b != null) {
        document.body.removeChild(b);
      }
      return document.body.removeChild(w);
    }
  });
  if (title) {
    t = new_dom_element({
      parentNode: w,
      className: "PopupTitle",
      innerHTML: title,
      style: {
        background: '#262626',
        padding: '5 10 3 10',
        height: '22px',
        fontSize: '12px',
        borderBottom: 'thin solid black',
        cursor: 'pointer',
        color: 'white'
      },
      onmousedown: function(evt) {
        old_x = evt.clientX;
        old_y = evt.clientY;
        top_x = parseInt(w.style.left);
        top_y = parseInt(w.style.top);
        document.addEventListener("mousemove", _drag_evt_func, true);
        document.addEventListener("mouseup", _drag_end_func, true);
        return typeof evt.preventDefault === "function" ? evt.preventDefault() : void 0;
      }
    });
  }
  res = new_dom_element({
    parentNode: w,
    className: "PopupWindow",
    style: {
      padding: "6px",
      height: '100%',
      color: '#262626'
    }
  });
  if (params.child != null) {
    res.appendChild(params.child);
  }
  return res;
};

},{"url":7,"xhr2":9}],3:[function(require,module,exports){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

},{}],4:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],5:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],6:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":4,"./encode":5}],7:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":8,"punycode":3,"querystring":6}],8:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],9:[function(require,module,exports){
module.exports = XMLHttpRequest;

},{}]},{},[1]);
